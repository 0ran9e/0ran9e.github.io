<!DOCTYPE html>






  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next-me.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next-me.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next-me.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo-me.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="文件操作注意区分系统调用和标准C库函数，一般来说，使用文件描述符的是系统调用，而使用文件指针的是标准C库函数。区分一个函数是系统调用还是库函数的依据是：①是否访问内核数据结构、②是否访问外部硬件资源。二者任一则是系统调用，二者均无则是库函数。 打开、关闭文件open、close123456//打开一个文件，返回其文件描述符。int open(const char *pathname, int fl">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="http://0ran9e.com/2020/03/01/Linux系统编程/index.html">
<meta property="og:site_name" content="0ran9e&#39;s Blog">
<meta property="og:description" content="文件操作注意区分系统调用和标准C库函数，一般来说，使用文件描述符的是系统调用，而使用文件指针的是标准C库函数。区分一个函数是系统调用还是库函数的依据是：①是否访问内核数据结构、②是否访问外部硬件资源。二者任一则是系统调用，二者均无则是库函数。 打开、关闭文件open、close123456//打开一个文件，返回其文件描述符。int open(const char *pathname, int fl">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/top.png">
<meta property="og:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/UDP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80.png">
<meta property="og:updated_time" content="2020-03-31T16:13:27.058Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux系统编程">
<meta name="twitter:description" content="文件操作注意区分系统调用和标准C库函数，一般来说，使用文件描述符的是系统调用，而使用文件指针的是标准C库函数。区分一个函数是系统调用还是库函数的依据是：①是否访问内核数据结构、②是否访问外部硬件资源。二者任一则是系统调用，二者均无则是库函数。 打开、关闭文件open、close123456//打开一个文件，返回其文件描述符。int open(const char *pathname, int fl">
<meta name="twitter:image" content="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/top.png">






  <link rel="canonical" href="http://0ran9e.com/2020/03/01/Linux系统编程/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux系统编程 | 0ran9e's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">0ran9e's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">君子慎独</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://0ran9e.com/2020/03/01/Linux系统编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="0ran9e">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0ran9e's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux系统编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-01 17:00:42" itemprop="dateCreated datePublished" datetime="2020-03-01T17:00:42+08:00">2020-03-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/计算机/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>注意区分<strong>系统调用</strong>和<strong>标准C库函数</strong>，一般来说，使用文件描述符的是系统调用，而使用文件指针的是标准C库函数。区分一个函数是系统调用还是库函数的依据是：①是否访问内核数据结构、②是否访问外部硬件资源。二者任一则是系统调用，二者均无则是库函数。</p>
<h2 id="打开、关闭文件"><a href="#打开、关闭文件" class="headerlink" title="打开、关闭文件"></a>打开、关闭文件</h2><h3 id="open、close"><a href="#open、close" class="headerlink" title="open、close"></a>open、close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开一个文件，返回其文件描述符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;    <span class="comment">//文件路径 打开方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;    <span class="comment">//文件路径 打开方式 创建时用的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭一个文件，成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;    <span class="comment">//文件描述符</span></span><br></pre></td></tr></table></figure>
<p>flags 和 mode 都是一组掩码的合成值，flags 表示打开或创建的方式，mode 表示文件的访问权限。</p>
<p>其中flags的可选项有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">掩码</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O_RDONLY</td>
<td style="text-align:center">以只读的方式打开</td>
</tr>
<tr>
<td style="text-align:center">O_WRONLY</td>
<td style="text-align:center">以只写的方式打开</td>
</tr>
<tr>
<td style="text-align:center">O_RDWR</td>
<td style="text-align:center">以读写的方式打开</td>
</tr>
<tr>
<td style="text-align:center">O_CREAT</td>
<td style="text-align:center">如果文件不存在，则创建文件</td>
</tr>
<tr>
<td style="text-align:center">O_EXCL</td>
<td style="text-align:center">仅与 O_CREAT 连用，如果文件已存在，则强 制 open 失败</td>
</tr>
<tr>
<td style="text-align:center">O_TRUNC</td>
<td style="text-align:center">如果文件存在，将文件的长度截至 0</td>
</tr>
<tr>
<td style="text-align:center">O_APPEND</td>
<td style="text-align:center">已追加的方式打开文件，每次调用 write 时， 文件指针自动先移到文件尾，用于多进程写同一个文件的情况。</td>
</tr>
<tr>
<td style="text-align:center">O_NONBLOCK</td>
<td style="text-align:center">非阻塞方式打开，无论有无数据读取或等 待，都会立即返回进程之中。</td>
</tr>
<tr>
<td style="text-align:center">O_NODELAY</td>
<td style="text-align:center">非阻塞方式打开</td>
</tr>
<tr>
<td style="text-align:center">O_SYNC</td>
<td style="text-align:center">同步打开文件，只有在数据被真正写入物理设备设备后才返回。用得不多，对磁盘伤害比较大。</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h4 id="示例一：使用open打开一个文件"><a href="#示例一：使用open打开一个文件" class="headerlink" title="示例一：使用open打开一个文件"></a>示例一：使用open打开一个文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意这个权限是会受该用户的掩码影响的，比如虽然此时是666，但因root掩码002，所以最后权限为 664</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR|O_CREAT, <span class="number">0666</span>);	</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>, fd);</span><br><span class="line">  	close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fopen、fclose"><a href="#fopen、fclose" class="headerlink" title="fopen、fclose"></a>fopen、fclose</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功返回一个文件指针，失败返回NULL</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;    <span class="comment">//文件路径 打开方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;    <span class="comment">//文件路径</span></span><br></pre></td></tr></table></figure>
<p>其中参数mode的值可以为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">读</th>
<th style="text-align:center">写</th>
<th style="text-align:center">位置</th>
<th style="text-align:center">截断原内容</th>
<th style="text-align:center">创建</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rb</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">文件头</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">rb+</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">文件头</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">wb</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">文件头</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">wb+</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">文件头</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">ab</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">文件尾</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">ab+</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">文件尾</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</div>
<p>实际上 <code>fopen</code> 是<strong>调用</strong> <code>open</code> 来实现的，二者的重要区别在于 <code>open</code> 是系统调用，而  <code>fopen</code> 是标准C库函数。<code>open</code> 打开文件时，仅在内核区新建并管理该文件的文件描述符。而用 <code>fopen</code> 打开文件时，除去同样在内核新建的文件描述符外，还在用户区开辟了一个空间缓冲区（一般为<strong>4K的整数倍</strong>），当我们用 <code>fread</code> <code>fwrite</code> 这类标准C库函数时，我们可以直接使用这个空间缓冲区，从而达到减少频繁调用系统的效果。</p>
<p>所以，当我们用 <code>fread</code> <code>fwrite</code> 这类标准C库函数时，我们可以直接使用这个空间缓冲区，从而达到减少频繁调用系统的效果。如果使用mmap时，那肯定优先选择open，因为我们此时是用不到用户区的缓冲区的，但像每次只读取一个字节之类的操作时，一般不会考虑 <code>read</code> 而是使用 <code>fgetc</code> 就是因为这样的原因。如果我们坚持要使用 <code>open</code> 的话该如何提高效率呢？此时注意每次读或写长度都最好用4K的整数倍以减少系统调用即可。</p>
<p>综上所述，可以明白有文件指针时，必定已有与之对应的文件描述符。所以将文件指针转换成文件描述符的函数 <code>int fileno(FILE *stream)</code>  原理就是直接去内核区找对对应的文件描述符。但是如果要从文件描述符得到文件指针，此时用户区是没有与之对应的缓冲区的，所以函数 <code>FILE *fdopen(int fildes, const char *mode)</code> 就是在用户区开辟一个新的缓冲区作为文件指针。</p>
<h4 id="示例一：文件指针转换文件描述符"><a href="#示例一：文件指针转换文件描述符" class="headerlink" title="示例一：文件指针转换文件描述符"></a>示例一：文件指针转换文件描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb+"</span>);</span><br><span class="line">    ERROR_CHECK(fp, <span class="literal">NULL</span>, <span class="string">"fopen"</span>);</span><br><span class="line">    <span class="comment">//因为是调用open来实现的，所以此时文件描述符3即是打开的文件</span></span><br><span class="line">    fd = fileno(fp);</span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>, fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：文件描述符转换文件指针"><a href="#示例二：文件描述符转换文件指针" class="headerlink" title="示例二：文件描述符转换文件指针"></a>示例二：文件描述符转换文件指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    FILE *fp = fdopen(fd, <span class="string">"rb+"</span>);</span><br><span class="line">    ERROR_CHECK(fp, <span class="literal">NULL</span>, <span class="string">"fdopen"</span>);</span><br><span class="line">    <span class="comment">//如果在这里close, fd关闭时后面也将报错, 因为fp是依赖于fd的</span></span><br><span class="line">    <span class="comment">//close(fd);</span></span><br><span class="line">    <span class="keyword">char</span> *p = fgets(buf, <span class="keyword">sizeof</span>(buf), fp);</span><br><span class="line">    ERROR_CHECK(p, <span class="literal">NULL</span>, <span class="string">"fgets"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    fclose(fp);    <span class="comment">//关闭fp时也关闭fd</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h2><h3 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fd的内容读到buf中，返回读到的个数，出错返回-1，读完返回0</span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);    <span class="comment">//文件描述符 缓冲区 长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//buf的内容写到fd中，返回写入的个数，出错返回-1，写完返回0</span></span><br><span class="line"><span class="keyword">ssize_t</span> write(inf fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);    <span class="comment">//文件描述符 缓冲区 长度</span></span><br></pre></td></tr></table></figure>
<h4 id="示例一：read的简单示例"><a href="#示例一：read的简单示例" class="headerlink" title="示例一：read的简单示例"></a>示例一：read的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s, ret = %d\n"</span>, buf, ret);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：write的简单示例"><a href="#示例二：write的简单示例" class="headerlink" title="示例二：write的简单示例"></a>示例二：write的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意我们将一个整型写到文件时，是二进制写入的，在VIM中 :%!xxd 转成16进制查看</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>, fd);</span><br><span class="line">    write(fd, &amp;fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fread、fwrite"><a href="#fread、fwrite" class="headerlink" title="fread、fwrite"></a>fread、fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件流stream中读取nmemb个元素，写到ptr指向的内存中，每个元素的大小为size个字节</span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ptr指向的内存中读取nmemb个元素，写到文件流stream中，每个元素size个字节</span></span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="改变文件大小"><a href="#改变文件大小" class="headerlink" title="改变文件大小"></a>改变文件大小</h2><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="ftruncate"><a href="#ftruncate" class="headerlink" title="ftruncate"></a>ftruncate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将参数fd指定的文件大小改为参数length的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;    <span class="comment">//文件描述符 修改后的文件大小</span></span><br></pre></td></tr></table></figure>
<p>fd必须是以写入模式打开的文件，如果原文件大小比参数length打，则超过的部分被删除。因为 <code>mmap</code> 利用DMA是不能修改文件大小的，因此这个函数经常<strong>配合<code>mmap</code>使用</strong>。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件的读取点移动到指定位置，返回距离文件开头的位置</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);    <span class="comment">//文件描述符 偏移量 从哪开始偏移</span></span><br></pre></td></tr></table></figure>
<h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件的读取点移动到指定位置，成功返回0，设置error no</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数 whence 可以为：<strong>SEEK_SET</strong> 从文件头开始计算、<strong>SEEK_CUR</strong> 从当前指针开始计算、<strong>SEEK_END</strong> 从文件尾开始计算。<code>lseek</code> 相当于 <code>fseek</code> 与 <code>ftell</code> 组合实现的效果。</p>
<p>当偏移量大于文件本身的大小时，会改变文件大小并将超出部分填0。这一特性和 <code>ftruncate</code> 一样，经常用来<strong>配合 <code>mmap</code> 使用</strong>。</p>
<h3 id="示例一：lseek的简单示例"><a href="#示例一：lseek的简单示例" class="headerlink" title="示例一：lseek的简单示例"></a>示例一：lseek的简单示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件的读写指针偏移到离首部5的位置</span></span><br><span class="line">    <span class="keyword">int</span> ret = lseek(fd, <span class="number">5</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pos = %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：lseek实现文件空洞"><a href="#示例二：lseek实现文件空洞" class="headerlink" title="示例二：lseek实现文件空洞"></a>示例二：lseek实现文件空洞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT);</span><br><span class="line">    lseek(fd, <span class="number">1024</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;    <span class="comment">//文件路径 stat结构体指针</span></span><br></pre></td></tr></table></figure>
<h3 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;    <span class="comment">//文件描述符 stat 结构体指针</span></span><br></pre></td></tr></table></figure>
<p>参数stat是个<strong>传出参数</strong>，他的具体成员如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">       <span class="keyword">dev_t</span>         st_dev;        <span class="comment">/* 如果是设备，返回设备表述符，否则为 0*/</span></span><br><span class="line">       <span class="keyword">ino_t</span>         st_ino;        <span class="comment">/* i节点号*/</span></span><br><span class="line">       <span class="keyword">mode_t</span>        st_mode;       <span class="comment">/* 文件类型与权限，1111 000 111 111 111（重要）*/</span>	                                   <span class="comment">/* 前4位文件类型  后12位都是权限 */</span></span><br><span class="line">       <span class="keyword">nlink_t</span>       st_nlink;      <span class="comment">/* 链接数 */</span></span><br><span class="line">       <span class="keyword">uid_t</span>         st_uid;        <span class="comment">/* 属主ID*/</span></span><br><span class="line">       <span class="keyword">gid_t</span>         st_gid;        <span class="comment">/* 组ID */</span></span><br><span class="line">       <span class="keyword">dev_t</span>         st_rdev;       <span class="comment">/* 设备类型*/</span></span><br><span class="line">       <span class="keyword">off_t</span>         st_size;       <span class="comment">/* 文件大小，字节表示（重要） */</span></span><br><span class="line">       <span class="keyword">blksize_t</span>     st_blksize;    <span class="comment">/* 块大小*/</span></span><br><span class="line">       <span class="keyword">blkcnt_t</span>      st_blocks;     <span class="comment">/* 块数 */</span></span><br><span class="line">       <span class="keyword">time_t</span>        st_atime;      <span class="comment">/* 最后访问时间*/</span></span><br><span class="line">       <span class="keyword">time_t</span>        st_mtime;      <span class="comment">/* 最后修改时间*/</span></span><br><span class="line">       <span class="keyword">time_t</span>        st_ctime;      <span class="comment">/* 最后权限修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于结构体的成员st_mode，有一组宏可以进行文件类型的判断：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S_ISLNK(mode)</td>
<td style="text-align:center">判断是否是符号链接</td>
</tr>
<tr>
<td style="text-align:center">S_ISREG(mode)</td>
<td style="text-align:center">判断是否是普通文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISDIR(mode)</td>
<td style="text-align:center">判断是否是目录</td>
</tr>
<tr>
<td style="text-align:center">S_ISCHR(mode)</td>
<td style="text-align:center">判断是否是字符型设备</td>
</tr>
<tr>
<td style="text-align:center">S_ISBLK(mode)</td>
<td style="text-align:center">判断是否是块设备</td>
</tr>
<tr>
<td style="text-align:center">S_ISFIFO(mode)</td>
<td style="text-align:center">判断是否是命名管道</td>
</tr>
<tr>
<td style="text-align:center">S_ISSOCK(mode)</td>
<td style="text-align:center">判断是否是套接字</td>
</tr>
</tbody>
</table>
</div>
<h4 id="示例一：打印文件的文件状态"><a href="#示例一：打印文件的文件状态" class="headerlink" title="示例一：打印文件的文件状态"></a>示例一：打印文件的文件状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    ret = stat(argv[<span class="number">1</span>], &amp;buf);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"stat"</span>);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//注意: getpwuid 和 getgrgid 根据uid和gid返回一个所有信息的结构体</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x  %ld  %s  %s  %ld  %s\n"</span>, buf.st_mode, buf.st_nlink, getpwuid(buf.st_uid)-&gt;pw_name,</span><br><span class="line">           getgrgid(buf.st_gid)-&gt;gr_name, buf.st_size, ctime(&amp;buf.st_mtime));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><h3 id="mmap、munmap"><a href="#mmap、munmap" class="headerlink" title="mmap、munmap"></a>mmap、munmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>把磁盘映射到内存上，不读写文件就能修改文件内容，充分发挥DMA驱动器的效果。在处理比较大的文件，或有多个用户同时访问时，一般都采用mmap，因为比read和write的性能要高。<strong>因为mmap不能改变文件本身大小</strong>，所以若一个空文件映射到内存，若向这块内存写入内容，在munmap时就会报错。</p>
<p><code>addr</code>：映射的地址，一般 NULL 自动分配</p>
<p><code>len</code>：文件大小，可用<strong>stat</strong>获取，工作中要<strong>4K对齐</strong></p>
<p><code>prot</code>：映射到内存的权限，位权限，有PROT_EXEC(可执行)、PROT_READ(可读)、ROT_WRITE(可写)</p>
<p><code>flags</code>：标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)，通常使用下面两个选项</p>
<ul>
<li>MAP_SHARED:  共享映射，会将映射区所做的操作反映到物理设备（磁盘）上。如在<strong>进程间通信</strong>时必须使用这个。</li>
<li>MAP_PRIVATE：私有映射，映射区所做的修改不会反映到物理设备</li>
</ul>
<p><code>fd</code>：文件描述符</p>
<p><code>offset</code>：偏移</p>
<h3 id="示例一：mmap简单示例"><a href="#示例一：mmap简单示例" class="headerlink" title="示例一：mmap简单示例"></a>示例一：mmap简单示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>, fd);</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">5</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span> *)<span class="number">-1</span>, <span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">5</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line"></span><br><span class="line">    munmap(p, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a>文件描述符的复制</h2><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>系统调用函数 dup 和 dup2 可以实现文件描述符的复制，经常用来重定向进程的stdin(0),stdout(1),stderr(2)。</p>
<p>dup 返回新的文件描述符(没有使用的文件描述符的最小编号)。这个新的描述符是旧文件描述符 的拷贝。这意味着两个描述符共享同一个数据结构。</p>
<p>dup2 允许调用者用一个有效描述符(oldfd)和目标描述符(newfd)，函数成功返回时，目标描述符将 变成旧描述符的复制品，此时两个文件描述符现在都指向同一个文件，并且是函数第一个参数(也就是 oldfd)指向的文件。</p>
<h3 id="示例一：dup版重定向标准输出"><a href="#示例一：dup版重定向标准输出" class="headerlink" title="示例一：dup版重定向标准输出"></a>示例一：dup版重定向标准输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd, fd_copy;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now you see me\n"</span>);</span><br><span class="line">    close(<span class="number">1</span>);           <span class="comment">//关闭标准输出</span></span><br><span class="line">    fd_copy = dup(fd);  <span class="comment">//文件描述符的复制</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd_copy = %d\n"</span>, fd_copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now you don't\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：dup2版重定向标准输出"><a href="#示例二：dup2版重定向标准输出" class="headerlink" title="示例二：dup2版重定向标准输出"></a>示例二：dup2版重定向标准输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd, fd_copy;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now you see me\n"</span>);</span><br><span class="line">    fd_copy = dup2(fd, <span class="number">1</span>);    <span class="comment">//文件描述符的复制</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd_copy = %d\n"</span>, fd_copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now you don't\n"</span>);</span><br><span class="line"></span><br><span class="line">    dup2(<span class="number">100</span>, <span class="number">1</span>);    <span class="comment">//标准输出复原</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now you see me\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="几个常用的文件操作函数"><a href="#几个常用的文件操作函数" class="headerlink" title="几个常用的文件操作函数"></a>几个常用的文件操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变文件权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span></span>;    <span class="comment">//mode 形如:0777</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前文件的绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;    <span class="comment">//通常可用 getcwd(NULL, 0)</span></span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h1><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，失败返回 -1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;    <span class="comment">//文件路径 权限,如0777</span></span><br></pre></td></tr></table></figure>
<p>注意此处的权限也是受掩码umask影响的。</p>
<h2 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0，失败返回 -1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;    <span class="comment">//文件路径</span></span><br></pre></td></tr></table></figure>
<h2 id="打开文件夹"><a href="#打开文件夹" class="headerlink" title="打开文件夹"></a>打开文件夹</h2><p><strong>opendir</strong>返回的<strong>DIR</strong>结构就像一个链表一样，每次<strong>readdir</strong>一次，就会将指针往后面移动一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;    <span class="comment">//打开一个文件夹，返回一个 DIR指针</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="读取文件夹下的信息"><a href="#读取文件夹下的信息" class="headerlink" title="读取文件夹下的信息"></a>读取文件夹下的信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个dirent结构体指针</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;    <span class="comment">//传入一个DIR指针</span></span><br></pre></td></tr></table></figure>
<p>这个<code>dirent</code>结构体的成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">	<span class="keyword">ino_t</span>  d_ino;             <span class="comment">/* inode number(此目录进入点的 inode) */</span></span><br><span class="line">	<span class="keyword">off_t</span>  d_off;             <span class="comment">/* offset to the next dirent(目录开头到进入点的位移 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;  <span class="comment">/* length of this record(目录名的长度) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;     <span class="comment">/* type of file(所指的文件类型) 举例: 4为文件夹*/</span></span><br><span class="line">	<span class="keyword">char</span>   d_name[<span class="number">256</span>];       <span class="comment">/* filename(文件名) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="示例一：打印当前目录的所有文件"><a href="#示例一：打印当前目录的所有文件" class="headerlink" title="示例一：打印当前目录的所有文件"></a>示例一：打印当前目录的所有文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((p = readdir(dir))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inode = %llu, len = %d, type = %d,  filename = %s\n"</span>, </span><br><span class="line">               p-&gt;d_ino, p-&gt;d_reclen, p-&gt;d_type, p-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：文件夹的深度遍历"><a href="#示例二：文件夹的深度遍历" class="headerlink" title="示例二：文件夹的深度遍历"></a>示例二：文件夹的深度遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printDir</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    ERROR_CHECK(dir, <span class="literal">NULL</span>, <span class="string">"opendir"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((p = readdir(dir))) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p-&gt;d_name,<span class="string">"."</span>) || !<span class="built_in">strcmp</span>(p-&gt;d_name, <span class="string">".."</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s%s\n"</span>, width, <span class="string">" "</span>,  p-&gt;d_name);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"%s%s%s"</span>,path, <span class="string">"/"</span>, p-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;d_type == <span class="number">4</span>) &#123;</span><br><span class="line">            printDir(buf, width+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    printDir(argv[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="文件夹定位"><a href="#文件夹定位" class="headerlink" title="文件夹定位"></a>文件夹定位</h2><h3 id="telldir"><a href="#telldir" class="headerlink" title="telldir"></a>telldir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> telldir(DIR *dir);    <span class="comment">//返回目录流当前的读取位置</span></span><br></pre></td></tr></table></figure>
<h3 id="seekdir"><a href="#seekdir" class="headerlink" title="seekdir"></a>seekdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dir, <span class="keyword">off_t</span> offset)</span></span>;    <span class="comment">//用来设置目录流当前的读取位置</span></span><br></pre></td></tr></table></figure>
<h3 id="rewinddir"><a href="#rewinddir" class="headerlink" title="rewinddir"></a>rewinddir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dir)</span></span>;   <span class="comment">//重新定位到目录文件的头部</span></span><br></pre></td></tr></table></figure>
<h3 id="示例一：打印-seekdir-c-文件的下一个文件"><a href="#示例一：打印-seekdir-c-文件的下一个文件" class="headerlink" title="示例一：打印 seekdir.c 文件的下一个文件"></a>示例一：打印 seekdir.c 文件的下一个文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    DIR* dir;</span><br><span class="line">    dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    ERROR_CHECK(dir, <span class="literal">NULL</span>, <span class="string">"opendir"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((p = readdir(dir))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inode = %ld, len = %d, type = %d, filename = %s\n"</span>, </span><br><span class="line">               p-&gt;d_ino, p-&gt;d_reclen, p-&gt;d_type, p-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p-&gt;d_name, <span class="string">"seekdir.c"</span>)) &#123;</span><br><span class="line">            pos = telldir(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rewinddir(dir);</span></span><br><span class="line">    seekdir(dir, pos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n"</span>);</span><br><span class="line">    p = readdir(dir);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inode = %ld, len = %d, type = %d, filename = %s\n"</span>, </span><br><span class="line">           p-&gt;d_ino, p-&gt;d_reclen, p-&gt;d_type, p-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="几个文件夹的函数"><a href="#几个文件夹的函数" class="headerlink" title="几个文件夹的函数"></a>几个文件夹的函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改当前目录，即切换目录，相当于 cd 命令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;    <span class="comment">// 修改后的路径</span></span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>进程是一个程序一次执行的过程，它和程序有本质区别。<strong>程序是静态的</strong>，它是一些保存在磁盘上的 指令的有序集合。<strong>而进程是一个动态的概念</strong>，它是一个运行着的程序，包含了进程的动态创建、调度和消亡的过程，是 Linux 的<strong>基本调度单位</strong>。那么从系统的角度看如何描述并表示它的变化呢？在这里，是通过进程控制块(PCB)来描述的。进程控制块包含了进程的描述信息、控制信息以及资源信息，它是进程的一个静态描述。</p>
<p>内核使用进程来控制对 CPU 和其他系统资源的访问，并且使用进程来决定在 CPU 上运行哪个程序， 运行多久以及采用什么特性运行它。内核的调度器负责在所有的进程间分配 CPU 执行时间，称为<strong>时间片 (time slice)</strong>，它轮流在每个进程分得的时间片用完后从进程那里抢回控制权。</p>
<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>OS 会为每个进程分配一个唯一的整型 ID，做为进程的<strong>标识号(pid)</strong>。进程除了自身的 ID 外，还有 <strong>父进程 ID(ppid)</strong>。所有进程的祖先进程是同一个进程，它叫做 <strong>init 进程</strong>，ID 为 1，init 进程是内核<strong>自举</strong>后的一个启动的进程。init 进程负责引导系统、启动守护(后台)进程并且运行必要的程序。</p>
<p>进程的pid和ppid可以分别通过函数 <code>getpid()</code> 和 <code>getppid()</code> 获得。</p>
<h4 id="示例一：获得进程的pid与ppid"><a href="#示例一：获得进程的pid与ppid" class="headerlink" title="示例一：获得进程的pid与ppid"></a>示例一：获得进程的pid与ppid</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, ppid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    ppid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %d, ppid = %d\n"</span>, pid, ppid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程的运行身份"><a href="#进程的运行身份" class="headerlink" title="进程的运行身份"></a>进程的运行身份</h3><p>进程在运行过程中，必须具有一类似于用户的身份，以便进行进程的权限控制，<strong>缺省情况下，哪个登录用户运行程序，该程序进程就具有该用户的身份</strong>。例如，假设当前登录用户为 gotter,他运行了 ls 程序，则 ls 在运行过程中就具有 gotter 的身份，该 ls 进程的用户 ID 和组 ID 分别为 gotter 和 gotter 所属的组。这类型的 ID 叫做进程的<strong>真实用户 ID</strong> 和<strong>真实组 ID</strong>。真实用户 ID 和真实组 ID 可以通过函数 <code>getuid()</code>和<code>getgid()</code>获得。</p>
<p>与真实 ID 对应，进程还具有<strong>有效用户 ID</strong> 和<strong>有效组 ID</strong> 的属性，内核对进程的访问权限检查时，它 检查的是进程的有效用户 ID 和有效组 ID，而不是真实用户 ID 和真实组 ID。缺省情况下，用户的(有效用户 ID 和有效组 ID)与(真实用户 ID 和真实组 ID)是相同的。有效用户 id 和有效组 id 通过函数 <code>geteuid()</code>和 <code>getegid()</code>获得。</p>
<p>分割出一个有效用户ID是很有用的。比如说，用户的密码是存储在 <code>/etc/shadow</code> 里的，但这个文件的权限是 <code>rw-r-----</code> ，即只有root用户才能进行写操作。其他用户能修改这个文件的原因，就在于 <code>passwd</code> 指令的权限是 <code>rwsr-xr-x</code> ，用户权限的 <strong>s</strong>，表示权限提升。当其他非root用户执行这个程序时，用户的权限会被提升到 <code>passwd</code> 这个指令的用户身份，即 <strong>此时有效用户ID等于该指令用户的ID</strong>，所以就能够修改 <code>/ect/shadow</code> 内的内容。</p>
<h4 id="示例一：显示进程的四种运行身份"><a href="#示例一：显示进程的四种运行身份" class="headerlink" title="示例一：显示进程的四种运行身份"></a>示例一：显示进程的四种运行身份</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid:%d, gid:%d, euid:%d, egid:%d\n"</span>,</span><br><span class="line">           getuid(),getgid(),geteuid(),getegid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程状态与管理"><a href="#进程状态与管理" class="headerlink" title="进程状态与管理"></a>进程状态与管理</h3><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free               # 查看当前内存使用情况 </span><br><span class="line">ps -elf            # 较常用，信息显示多</span><br><span class="line">ps -aux            # 主要看CPU和内存的的使用情况</span><br></pre></td></tr></table></figure>
<p>程序的几种状态含义：</p>
<ul>
<li><strong>R</strong>(运行)：两次采样之间是不是有时间片消耗</li>
<li><strong>S</strong>(睡眠)：等待分配资源或信息，如 <code>scanf()</code> <code>getchar()</code> <code>select</code> </li>
<li><strong>T</strong>(暂停)：如ctrl+Z命令，被暂停的进程用 <code>bg</code> 恢复，<code>fg</code> 拉回前台</li>
<li><strong>Z</strong>(僵尸)：已介绍，但资源未被父进程回收</li>
</ul>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top                # 动态显示各个进程的情况</span><br></pre></td></tr></table></figure>
<p><img src="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/top.png" alt=""></p>
<p>介绍其中比较重要的几项：</p>
<ul>
<li><strong>load average</strong>：平均负载，一般对于单个 cpu 来说，负载在 0~1.00 之间是正常的，超过 1.00 须引起注意。在多核 cpu 中，系统平均负载不应该高于 cpu 核心的总数。</li>
<li><strong>us</strong>：用户空间占用 cpu 百分比</li>
<li><strong>sy</strong>：内核空间占用 cpu 百分比</li>
<li><strong>id</strong>：id 空闲 cpu 百分比，反映一个系统 cpu 的闲忙程度，越大越空闲。<strong>us+sy+id=1</strong></li>
</ul>
<h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p><img src="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>每个进程都运行在各自独立的虚拟地址空间，因此， 即使一个进程发生了异常，它也不会影响到系统的其他进程。Linux中的进程包含3个段，分别为<strong>数据段</strong>、<strong>代码段</strong>和<strong>堆栈段</strong></p>
<ul>
<li><p><strong>数据段</strong>：放全局变量、常数以及动态数据分配的数据空间。数据段分成<strong>普通数据段</strong>(包括可读可写<strong>/</strong>只读数据段，存放静态初始化的全局变量或常量)、<strong>BSS</strong> 数据段(存放未初始化的全局变量)以及<strong>堆</strong>(存放动态分配的数据)。</p>
</li>
<li><p><strong>代码段</strong>：存放的是程序代码的数据。</p>
</li>
<li><strong>堆栈段</strong>：存放的是子程序的返回地址、子程序的参数以及程序的局部变量等。</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程返回子进程pid, 子进程返回 0. 失败返回 -1</span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>它从已存在进程中创建一个新进程。新进程为子进程， 而原进程为父进程。它和其他函数的区别在于：它<strong>执行一次返回两个值</strong>。</p>
<p>fork 函数创建子进程的过程为：使用 fork 函数得到的子进程是父进程的一个复制品，它从父进程继承了进程的地址空间，包括进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端，而<strong>子进程所独有的只有它的进程号、资源使用和计时器等</strong>。</p>
<p>简而言之就是：<strong>子进程复制了父进程0-3G用户空间的内容，以及父进程的PCB，</strong>并采用<strong>读时共享写时复制</strong>的原则。通过这种复制方式创建出子进程后，原有进程和子进程都从函数 <code>fork()</code> 返回， 各自继续往下运行。</p>
<h4 id="示例一：fork引出的写时复制"><a href="#示例一：fork引出的写时复制" class="headerlink" title="示例一：fork引出的写时复制"></a>示例一：fork引出的写时复制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程中 str = %s\n"</span>, str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程中 str 的地址为: %x\n"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程中 str = %s\n"</span>, str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程中 str 的地位为: %x\n"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先解释一个比较让人困惑的问题，<strong>为什么打印的字符串不同，但地址却是相同的呢？</strong>因为通常情况下，每个进程都会有独立的地址空间，为了提高资源利用率，我们所使用的地址都是虚拟地址。不同进程相同的虚拟地址显然可以对应不同的物理地址，因此虚拟地址相同而值不同就可以解释了。</p>
<p>这里主要是为了引出<strong>写时复制</strong>的概念：当一个子进程没有对某个数据信息进行修改时，子进程与父进程是共享同一块物理地址的，但当子进程对这个某个数据修改时，操作系统将会额外开辟一块物理空间，将这个数据复制过去。通过这种方式，可以很好地提高内存的利用率。</p>
<h4 id="示例二：关于缓冲区的易错点"><a href="#示例二：关于缓冲区的易错点" class="headerlink" title="示例二：关于缓冲区的易错点"></a>示例二：关于缓冲区的易错点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"how are you"</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am fine\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码容易误以为会打印一个 <code>&quot;how are you&quot;</code>  和两个 <code>&quot;I am fine&quot;</code> 。但实际上，会打印两次 <code>&quot;how are youI am fine\n&quot;</code> ，这是因为第一个 <code>printf()</code> 时没有<code>\n</code>来刷新缓冲区，因此这段<strong>缓冲区会一起被子进程共享</strong>过去，由此导致我们看到的结果。</p>
<h3 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span></span>;    <span class="comment">//path为指定的程序 arg为程序的参数</span></span><br></pre></td></tr></table></figure>
<p>在Linux下执行一个程序，其实是bash <code>fork()</code> 了一个子进程来执行这个程序，但为什么代码却是执行程序的代呢？这就是 <code>exec()</code> 函数族的作用，<code>execl()</code> 可以用其第一个参数指定的程序<strong>覆盖</strong>现有进程空间，也就是说，执行 <code>excel()</code> 函数后，它后面的所有代码都不再执行。</p>
<h4 id="示例一：execl的简单示例"><a href="#示例一：execl的简单示例" class="headerlink" title="示例一：execl的简单示例"></a>示例一：execl的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d] = %s\n"</span>, argc, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am print process\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execl.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// execl 最后一个参数必为NULL，用来告诉函数在哪结束</span></span><br><span class="line">    execl(<span class="string">"./print"</span>, <span class="string">"execl_creat"</span>, <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"you can't see me\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>system 函数通过调用 shell 程序 <code>~/bin/sh –c</code> 来执行 string 所指定的命令，该函数在内部是通过调用 <code>execve(&quot;/bin/sh&quot;, ...)</code> 函数来实现的。通过 system 创建子进程后，原进程和子进程各自运行，相互间关联较少。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>用 fork 函数启动一个子进程时，子进程就有了它自己的生命并将独立运行。如果父进程先于子进程退出，则子进程成为<strong>孤儿进程</strong>，此时将自动被 PID 为 1 的进程 <strong>(即 init)接管</strong>。孤儿进程退出后，它的清理工作由祖先进程 init 自动处理。但在 init 进程清理子进程之前，它一直消耗系统的资源，所以要尽量避免。</p>
<h4 id="示例一：制造一个孤儿进程"><a href="#示例一：制造一个孤儿进程" class="headerlink" title="示例一：制造一个孤儿进程"></a>示例一：制造一个孤儿进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>ps -elf | grep a.out</code> 可以看到此时子进程还在运行，且其父进程是1号进程。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);   <span class="comment">// pid = -1，则等待所有子进程</span></span><br></pre></td></tr></table></figure>
<p>如果子进程先退出，系统不会自动清理掉子进程的环境，而<strong>必须</strong>由父进程调用 <code>wait()</code>  或 <code>waitpid()</code> 函数来完成清理工作，如果父进程不做清理工作，则已经退出的子进程将成为<strong>僵尸进程</strong>(defunct),在系统中如果存在的僵尸(zombie)进程过多，将会影响系统的性能，所以必须对僵尸进程进行处理。</p>
<p><code>wait()</code> 和 <code>waitpid()</code>  <strong>都将暂停</strong>父进程，等待一个已经退出的子进程，并进行清理工作，注意二者的区别在于：</p>
<p><code>wait()</code> 函数<strong>随机地等待</strong>一个已经退出的子进程，并返回该子进程的 pid。而<code>waitpid()</code> <strong>等待指定</strong> pid 的子进程，如果为 -1 表示等待所有子进程。</p>
<p>注意这两个函数的参数 <strong>wstatus</strong> 是一个<strong>传出参数</strong>，存放子进程的退出状态。通常用下面四个宏来获取宏状态：</p>
<ul>
<li><code>WIFEXITED(status)</code> 如果子进程正常结束，就返回一个非 0 值<ul>
<li><code>WEXITSTATUS(status)</code> 上宏为真，就返回子进程的退出状态（exit参数）</li>
</ul>
</li>
<li><code>WIFSIGNALED(status)</code> 如果子进程异常终止，就返回一个非 0 值<ul>
<li><code>WTERMSIG(status)</code> 如果上宏为真，就返回使进程终止的那个信号的编号</li>
</ul>
</li>
</ul>
<p>options 用于改变 <code>waitpid()</code> 的行为，其中最常用的是 <strong>WNOHANG</strong>，它表示无论子进程是否退出都将立即返回，不会将调用者的执行挂起，超时则返回0。如果options为0，则阻塞等待子进程结束。</p>
<h4 id="示例一：制造一个僵尸进程"><a href="#示例一：制造一个僵尸进程" class="headerlink" title="示例一：制造一个僵尸进程"></a>示例一：制造一个僵尸进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(!pid) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"I am child, I will be zombie, pid = %d\n"</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent, child's pid = %d\n"</span>, pid);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：wait-的简单示例"><a href="#示例二：wait-的简单示例" class="headerlink" title="示例二：wait() 的简单示例"></a>示例二：wait() 的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, pid = %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        pid = wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent, child pid = %d\n"</span>, pid);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"exit code = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child crash\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例三：waitpid-的简单示例"><a href="#示例三：waitpid-的简单示例" class="headerlink" title="示例三：waitpid() 的简单示例"></a>示例三：waitpid() 的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(!pid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, pid = %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">        <span class="comment">// 若将 0 改为 WNOHANG，则不会阻塞等待</span></span><br><span class="line">        child_pid = waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent, child pid = %d\n"</span>, child_pid);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"exit code = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child crash\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;        <span class="comment">// status 最后在130以内，因为之后的很多都是系统设定的</span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<p>进程有5种终止方式：</p>
<ul>
<li>main 函数的自然返回</li>
<li>调用 <code>exit()</code> 函数</li>
<li>调用 <code>_exit()</code> 函数</li>
<li>调用 <code>abort()</code> 函数</li>
<li>接收到能使进程终止的信号，如ctrl+c (SIGINT)、ctrl+/ (SIGQUIT)</li>
</ul>
<p>前三种属于正常终止，后两种属于非正常终止。两种方式在进程终止时都将执行相同的关闭打开的文件，释放占用的内存等资源。区别在于后两种终止会导致有些代码不会正常地执行，比如对象的析构等。</p>
<p><code>exit()</code> 和 <code>_exit()</code> 都是用来终止进程的，当程序执行到这两个函数时时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止本程序的运行。二者的区别在于 <code>exit()</code> 函数在退出之前会检查文件的打开情况，<strong>把文件缓冲区中的内容写回文件</strong>。</p>
<p>这里顺便介绍一下<strong>缓冲I/O</strong>，其特征就是对应每一个打开的文件，在<strong>内存中</strong>都有一片缓冲区。每次读文件时，会连续读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区中读取；同样，每次写文件的时候，也仅仅是写入内存中的缓冲区，等满足一定的条件(如达到一定数量或遇到特定字符等)，再将缓冲区中的内容一次性写入文件。这种技术大大<strong>增加了文件读写的速度</strong>，但也为编程带来了麻烦。比如有一些数据，认为已经写入文件，实际上因为没有满足特定的条件，它们还只是保存在缓冲区内，这时用 <code>_exit()</code> 函数直接将进程关闭，缓冲区中的数据就会丢失。因此，<strong>如想保证数据的完整性，建议使用 <code>exit()</code>  函数</strong>。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Daemon 运行在后台也称作<strong>后台服务进程</strong>， 它是没有控制终端与之相连的进程，它独立与控制终端、会话周期的执行某种任务。</p>
<p>那么为什么要引入守护进程呢？由于在 linux 中， 每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖这个终端，这个终端就称为这些进程的<strong>控制终端</strong>。当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它被执行开始运转，直到整个系统关闭时才退出。很多 Linux 下常见的命令如 inetd 和 ftpd，<strong>末尾的字母 d 通常就是指 daemon</strong>。</p>
<p>守护进程的<strong>特性</strong>：</p>
<ul>
<li><p>守护进程最重要的特性是后台运行</p>
</li>
<li><p>其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录已经文件创建掩码等。这些环境通常是守护进程从父进程那里继承下来的。</p>
</li>
<li><p>守护进程的启动方式</p>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>1. 创建子进程，父进程退出。</strong></p>
<p>调用 <code>fork()</code> 产生一个子进程，同时父进程退出。我们所有后续工作都在子进程中完成。这样做我们可以<strong>交出控制台的控制权，并为子进程作为进程组长作准备</strong>。由于父进程已经先于子进程退出，会造成子进程没有父进程，变成一个孤儿进程(orphan)。每当系统发现一 个孤儿进程，就会自动由 1 号进程收养它，这样，原先的子进程就会变成 1 号进程的子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>2. 在子进程中创建新会话。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取进程组id</span></span><br><span class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);  <span class="comment">// pid为要查看的进程，若为0，则代表自己</span></span><br><span class="line"><span class="comment">// 设置进程组id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;  <span class="comment">// pid:要创建进程组的进程，0表示自己。pgid:要加入的进程组id，0表示创建新的进程组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取会话组id</span></span><br><span class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid);</span><br><span class="line"><span class="comment">// 设置会话组id</span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p><strong>进程组：</strong>是一个或多个进程的集合。进程组有进程组 ID 来唯一标识。除了进程号(PID) 之外，进程组 ID(GID)也是一个进程的必备属性。每个进程都有一个<strong>组长进程</strong>，其组长进程的进程号等于进程组 ID。且该进程组 ID 不会因为组长进程的退出而受影响。</p>
<p><strong>会话周期：</strong>会话期是一个或多个<strong>进程组的集合</strong>。通常，一个会话开始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期。</p>
<p><strong>控制终端：</strong>由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖这个控制终端。</p>
<p>下面举一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="comment">// getpgid()参数为0表示当前程序的进程组id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, pid = %d, ppid = %d, pgid = %d\n"</span>,</span><br><span class="line">               getpid(), getppid(), getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// setpgid(0, 0);    若在这里创建新的进程组，则ctrl+c不会杀死子进程</span></span><br><span class="line">        <span class="comment">// setsid();         若在这里创建新的会话组，则ctrl+c也不会杀死进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent pid = %d, ppid = %d, pgid = %d\n"</span>,</span><br><span class="line">               getpid(), getppid(), getpgid(<span class="number">0</span>));</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序运行的过程中，因为 <code>ctrl+c</code> 是对一个<strong>进程组发送信号</strong>的，因此当程序执行时， 若用 <code>ctrl+c</code> 则会杀死父子进程。那么如何让子进程不接受这个信号继续运行下去呢？答案是离开父进程的进程组，然后自己再<code>setpgid()</code> 创建一个新的进程组。</p>
<p>会话组同理，也是使用 <code>getsid()</code> 与 <code>setsid()</code> 来进行会话组 id 的查看与新建，而且 <code>setsid()</code> 不像 <code>setpgid()</code> ，一个进程不能加入其他会话组，只能创建一个新的组，此时该进程即为这个会话组的组长。在上面的示例程序中，将 <code>setpgid(0, 0)</code> 改成 <code>setsid()</code> 即可创建新的会话组。</p>
<p>这样我们就能理解<strong>创建新会话的原因</strong>了：此时子进程作为一个孤儿进程，虽然父进程退出了，但会话期、进程组、控制终端并没有改变，因此，还不是真正意义上的独立开来。而调用 <code>setsid()</code> 函数会创建一个新的会话并自任该会话的组长，调用 <code>setsid()</code> 函数有下面 3 个作用：让进程摆脱原会话的控制、让进程摆脱原进程组的控制，让进程摆脱原控制终端的控制。</p>
<p><strong>3. 改变当前目录为根目录</strong>（可选）</p>
<p>使用 fork 函数创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件是不能卸载的，这对以后的使用会造成很多的不便。利用 <code>chdir(&quot;/&quot;)</code> 把当前工作目录切换到根目录。可选的原因主要是因为当前业界主要将数据与代码分开存盘，因此这个工作目录的改变因视情况选择。</p>
<p><strong>4. 重设文件权限掩码</strong></p>
<p>用 <code>umask(0)</code> 将文件权限掩码设为0，这样Deamon创建文件不用重新设置权限，简化工作流程。</p>
<p><strong>5. 关闭所有不需要的文件描述符</strong></p>
<p>新进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，而它们一直消耗系统资源。另外守护进程已经与所属的终端失去联系，那么从终端输入的字符不可能到达守护进程，守护进程中常规方法(如 <code>printf</code>)输出的字符也不可能在终端上显示。<strong>所以通常关闭从 0 到 MAXFILE 的所有文件描述符。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXFILE; i++)</span><br><span class="line">    close(i);</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Daemon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 退出父进程，使子进程成为孤儿进程</span></span><br><span class="line">    <span class="keyword">if</span>(fork()) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 改变工作目录</span></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="comment">// 设定掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        close(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Daemon();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都是不可见的，进程与进程之间不能相互访问，要<strong>交换数据必须通过内核</strong>。在内核中开辟一块缓冲区，两个进程通过这块缓冲区进行数据的交换，内核提供的这种机制就称为<strong>进程间通信</strong>。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="标准流管道"><a href="#标准流管道" class="headerlink" title="标准流管道"></a>标准流管道</h3><p>像文件操作有标准 io 流一样，管道也支持<strong>文件流模式</strong>。用来创建连接到另一进程的管 道，是通过函数 <code>popen()</code> 和 <code>pclose()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>标准流管道的工作方式很简单：若参数type以 <code>r</code> 模式打开，则返回的文件指针作为管道的读端，打开的程序的标准输出将被修改为管道的写端，所以此时就可以通过常用的stdio库函数来读取被调用程序的输出。同理，若参数是以 <code>w</code> 打开的话，调用程序就可以用 <code>fwrite()</code> 等输出函数向被调用程序发送数据，而被调用程序可以在自己的标准输入上读取这些数据。</p>
<h4 id="示例一：利用popen从被调用程序读数据"><a href="#示例一：利用popen从被调用程序读数据" class="headerlink" title="示例一：利用popen从被调用程序读数据"></a>示例一：利用popen从被调用程序读数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// popen_r.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    fp = popen(<span class="string">"./print"</span>, <span class="string">"r"</span>);</span><br><span class="line">    ERROR_CHECK(fp, <span class="literal">NULL</span>, <span class="string">"popen"</span>);</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s"</span>, buf);</span><br><span class="line">    pclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：利用popen向被调用程序写数据"><a href="#示例二：利用popen向被调用程序写数据" class="headerlink" title="示例二：利用popen向被调用程序写数据"></a>示例二：利用popen向被调用程序写数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// popen_w.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = <span class="string">"3 4"</span>;</span><br><span class="line"></span><br><span class="line">    fp = popen(<span class="string">"./add"</span>, <span class="string">"w"</span>);</span><br><span class="line">    ERROR_CHECK(fp, <span class="literal">NULL</span>, <span class="string">"popen"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, fp);</span><br><span class="line">    pclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>无名管道是 linux 进程间通信的一种方式，如命令 <code>ps -ef | grep ntp</code></p>
<p>无名管道的特点：</p>
<ul>
<li><p>只能在<strong>亲缘关系</strong>进程间通信(父子或兄弟)</p>
</li>
<li><p>半双工(固定的读端和固定的写端)</p>
</li>
<li><p>是特殊的文件，可以用 read、write 等，只能在内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回 0，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数 <code>pipe()</code> 用于创建一个无名管道，如果成功，pipefd[0]存放可读的文件描述符，pipefd[1]存放可写文件描述符。在使用时通常读端会关闭pipefd[1]，写端关闭pipefd[0]。这是为了<strong>保持半双工</strong>的特性，防止误操作。</p>
<p>此外，还需注意<strong>管道的读写行为</strong>：</p>
<ul>
<li>读管道<ul>
<li>管道中有数据：<code>read()</code> 返回实际读到的字节数</li>
<li>管道中无数据：<ul>
<li>写端关闭：<code>read()</code> 返回 0，就像是读到了文件结尾</li>
<li>写端未全关闭：<code>read()</code> 阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li>读端关闭：进程异常终止，也可捕捉 SIGPIPE 信号使进程不终止</li>
<li>读端未全关闭：<ul>
<li>管道已满：<code>write()</code> 阻塞</li>
<li>管道未满：<code>write()</code> 将数据写入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="示例一：无名管道的简单示例"><a href="#示例一：无名管道的简单示例" class="headerlink" title="示例一：无名管道的简单示例"></a>示例一：无名管道的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 读端存在fd[0], 写端存在fd[1]</span></span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="comment">// 子进程读, 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, gets = %s\n"</span>, buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子进程写, 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"Hello World"</span>, <span class="number">11</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p><strong>无名管道只能在亲缘关系</strong>的进程间通信大大限制了管道的使用，有名管道突破了这个限制，通过指定路径名的实现不相关进程间的通信。</p>
<h4 id="创建、删除FIFO文件"><a href="#创建、删除FIFO文件" class="headerlink" title="创建、删除FIFO文件"></a>创建、删除FIFO文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0, 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;    <span class="comment">//注意这里的权限mode也是受掩码umask影响的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="示例一：创建与删除FIFO文件"><a href="#示例一：创建与删除FIFO文件" class="headerlink" title="示例一：创建与删除FIFO文件"></a>示例一：创建与删除FIFO文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = mkfifo(argv[<span class="number">1</span>], <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// ret = unlink(argv[1]);    即为删除文件</span></span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"mkfifo"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打开、关闭FIFO文件"><a href="#打开、关闭FIFO文件" class="headerlink" title="打开、关闭FIFO文件"></a>打开、关闭FIFO文件</h4><p>对 FIFO 类型的文件的打开/关闭跟普通文件一样，都是使用 <code>open()</code> 和 <code>close()</code> 函数。如果打开时使用 <code>O_WRONLY</code> 选项，则打开 FIFO 的写入端，如果使用 <code>O_RDONLY</code> 选项，则打开 FIFO 的读取端，写入端和读取端都可以被几个进程同时打开。</p>
<p>如果以读取方式打开 FIFO，并且还没有其它进程以写入方式打开 FIFO，<code>open()</code> 将被阻塞；同样，如果以写入方式打开 FIFO，并且还没其它进程以读取方式 FIFO，<code>open()</code> 也将被阻塞。</p>
<p>管道的<strong>读写行为</strong>与上面的无名管道相同。</p>
<h4 id="示例一：命名管道的简单示例"><a href="#示例一：命名管道的简单示例" class="headerlink" title="示例一：命名管道的简单示例"></a>示例一：命名管道的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reader</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am reader fdr = %d\n"</span>, fdr);</span><br><span class="line">    read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gets: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//writer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am writer fdr = %d\n"</span>, fdw);</span><br><span class="line">    write(fdw, <span class="string">"now you see me"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：通过管道进行通信"><a href="#示例二：通过管道进行通信" class="headerlink" title="示例二：通过管道进行通信"></a>示例二：通过管道进行通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(argv[<span class="number">2</span>], O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am chat1 fdr = %d, fdw = %d\n"</span>, fdr, fdw);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//从标准输入读</span></span><br><span class="line">        read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//往管道里写, 发送给对端</span></span><br><span class="line">        write(fdw, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//读管道</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//显示数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am chat2 fdr = %d\n"</span>, fdw);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//读管道</span></span><br><span class="line">        read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//打印管道的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">        <span class="comment">//从标准输入读</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//写到管道中</span></span><br><span class="line">        write(fdw, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在这个例子中，打开读写管道的顺序交错着来，否则会发生死锁。</p>
<p><br></p>
<hr>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>来假设这样一种情况，若一个进程要给一千个进程发送消息，若使用管道的方法，则要创建一千个写管道才能做到，虽然可行但是相对繁琐。共享内存能很好的解决管道的这个问题，共享内存的本质是一段特殊的内存区域，进程间需要共享的数据被放在该共享内存区域中，所有<strong>需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中</strong>去。这样一个使用共享内存的进程可以将信息写入该空间，而另一个使用共享内存的进程又可以通过简单的内存读操作获取刚才写入的信息，使得两个不同进程之间进行了一次信息交换，从而实现进程间的通信。首先我们先来参考共享内存的几个重要函数：</p>
<h3 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建一个关键字，可以用该关键字关联一个共享内存段</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br></pre></td></tr></table></figure>
<p><code>pathname</code> 为文件名， <code>proj_id</code> 通常传入一非0字符。通过 pathname 和 proj_id 组合，可以创建唯一的 key 成功返回关键字，否则返回-1。</p>
<h4 id="示例一：ftok的简单示例"><a href="#示例一：ftok的简单示例" class="headerlink" title="示例一：ftok的简单示例"></a>示例一：ftok的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    key = ftok(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"key = %d\n"</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建或打开一共享内存段，该内存段由函数的第一个参数唯一创建。返回key值对应的共享内存id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code> 是一个与共享内存段相关联关键字，如果事先已经存在一个与指定关键字关联的共享内存段，则直接返回该内存段的标识，表示打开，如果不存在，则创建一个新的共享内存段。<code>key</code> 的值既可以用 <code>ftok()</code> 函数产生，也可以是 <strong>IPC_PRIVATE</strong> (用于创建一个只属于创建进程的共享内存，主要用于父子通信)，表示<strong>总是创建</strong>新的共享内存段。注意用IPC_PRIVATE创建的共享内存，其key值是为0的，这就阻断了非亲缘关系的进程想要使用这段共享内存的方式，这也可以解释为什么既有key又有shmid的原因。</p>
<p><code>size</code> 指定共享内存段的大小，以字节为单位。</p>
<p><code>shmflg</code> 是一掩码合成值，可以是访问权限值与(<strong>IPC_CREAT</strong> 或 <strong>IPC_EXCL</strong>)的合成。IPC_CREAT 表示如果不存在该内存段，则创建它。IPC_EXCL 表示如果该内存段存在，则函数返回失败结果(-1)。如果调用成功，返回内存段标识，否则返回-1。</p>
<p>创建成功后使用命令 <code>ipcs</code> 可以查看当前的共享内存，值得注意的是，共享内存不像 <code>malloc()</code> 申请的空间，共享内存在程序退出后是不会被删除的。可以使用 <code>ipcrm shm [shmid]</code> 来删除指定的共享内存。</p>
<h3 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将共享内存段映射到进程空间的某一地址。如果调用成功，返回映射后的进程空间的首地址，否则返回(char *)-1。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>shmid</code> 是共享内存段的标识 通常应该是 <code>shmget()</code> 的成功返回值。</p>
<p><code>shmaddr</code> 指定的是共享内存连接到当前进程中的地址位置。通常是 NULL，表示让系统来选择共享内存出现的地址。</p>
<p><code>shmflg</code> 是一组位标识，通常为 0 即可。</p>
<h4 id="示例一：shmget与shmat的简单组合使用"><a href="#示例一：shmget与shmat的简单组合使用" class="headerlink" title="示例一：shmget与shmat的简单组合使用"></a>示例一：shmget与shmat的简单组合使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">"shmget"</span>);</span><br><span class="line">    p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">"shmat"</span>);</span><br><span class="line">    <span class="comment">// 若再运行第二个程序, 并将下面一行改成puts(p), 即可打印共享内存中的内容 "hello"</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将共享内存段与进程空间分离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>shmaddr</code> 通常为 <code>shmat()</code> 的成功返回值。</p>
<p>将共享内存分离并没删除它，只是使得该共享内存对当前进程不在可用。</p>
<h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是共享内存的控制函数，可以用来删除共享内存段</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>shmid</code> 是共享内存段标识，通常应该是 <code>shmget()</code> 的成功返回值。</p>
<p><code>cmd</code> 是对共享内存段的操作方式，可选为 IPC_STAT,IPC_SET,IPC_RMID。<strong>通常为 IPC_RMID，表示删除共享内存段</strong>。</p>
<p><code>buf</code> 表示共享内存段的信息结构体数据，通常为 NULL。</p>
<h2 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a>存储映射</h2><p>存储映射使一个磁盘文件与存储空间中的一个缓冲区相映射，于是当从缓冲区中读数据，就相当于从文件中读数据。同样，向这个缓冲区中写数据，也相当于向文件中写数据。这样就可以在不用 <code>read()</code> 和 <code>write()</code> 的情况下，使用地址指针直接完成 I/O 操作，当然也能用来实现两个进程之间的通信。</p>
<p>在<strong>文件操作</strong>的内存映射有对mmap有相对详细的描述，具体可以跳过去看。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过 <code>mmap()</code> 实现的共享内存和前面的共享内存主要区别在于：<strong>是否要将信息存储下来，即是否对文件进行操作</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">10</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, mmap is : %s\n"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p, <span class="string">"Hello"</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列与 FIFO 很相似，都是一个队列结构，都可以有多个进程往队列里面写信息， 多个进程从队列中读取信息。但 FIFO 需要读、写的两端事先都打开，才能够开始信息传递 工作。而消息队列可以事先往队列中写信息，需要时再打开读取信息 。但是，消息队列先打 开读，仍然会阻塞，因为此时没有消息可读。</p>
<h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和访问一个消息队列。成功则返回一个唯一的消息队列标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code> 是唯一标识一个消息队列的关键字，如果为 IPC_PRIVATE(值为 0)，则创建一个只有创建者进程才可以访问的消息队列，可以用于父子间通信；非 0 值的key(可 以通过 <code>ftok()</code>  函数获得)表示创建一个可以被多个进程共享的消息队列;</p>
<p><code>msgflg</code> 指明队列的访问权限和创建标志，创建标志的可选值为 IPC_CREAT 和 IPC_EXCL ：</p>
<ul>
<li>IPC_CREAT：要么返回新创建的消息队列 id，要么返回具有相同 key 值的消息队列 id</li>
<li>PC_EXCL 和 IPC_CREAT 同时指定：只能创建新的消息队列，若队列存在，则调用失败并返回 -1</li>
</ul>
<h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来将消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>msqid</code> 指明消息队列的 ID，通常是 <code>msgget()</code>  函数成功的返回值</p>
<p><code>msgp</code> 是<strong>消息结构体</strong>，它的长度必须小于系统规定的上限，必须以一个长整型成员变量开始，接收函数将用这个成员变量来确定消息的类型。<strong>必须重写这个结构体</strong>， 其中第一个参数不能改，其他自定义。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* type of message */</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>]; <span class="comment">/* message text */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>msgsz</code> 是消息体的大小，每个消息体最大不要超过 4K</p>
<p><code>msgflg</code> 可以为 0(<strong>通常为 0</strong>)或 <strong>IPC_NOWAIT</strong>，如果设置 IPC_NOWAIT，则 <code>msgsnd()</code> 和 <code>msgrcv()</code> 都不会阻塞，此时如果队列满时调用 <code>msgsnd()</code> 或队列空时调用 <code>msgrcv()</code> 将返回错误</p>
<h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个消息队列中获取信息</span></span><br><span class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg);</span><br></pre></td></tr></table></figure>
<p>其中参数大部分均和 <code>msgsnd()</code> 的参数相同，不同之处在于多了一个参数 <code>msgtyp</code> ，可以看成是一个优先级相关的参数，他有三种选项：</p>
<ul>
<li>msgtyp == 0：接收队列中的第 1 个消息(通常为 0)</li>
<li>msgtyp &gt; 0：接收对列中的第 1 个类型等于 msgtyp 的消息</li>
<li>msgtyp &lt; 0：接收其类型小于或等于 msgtyp 绝对值的第 1 个最低类型消息</li>
</ul>
<h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列的控制函数，常用来删除消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>msqid</code> ：通常是由 <code>msgget()</code>  返回的消息队列标识符。</p>
<p><code>cmd</code> ：通常为 <strong>IPC_RMID</strong> 表示删除消息队列</p>
<p><code>buf</code>：通常为 NULL</p>
<h3 id="示例一：一个简单的消息发送与接受"><a href="#示例一：一个简单的消息发送与接受" class="headerlink" title="示例一：一个简单的消息发送与接受"></a>示例一：一个简单的消息发送与接受</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgget.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">64</span>];</span><br><span class="line">&#125;MGS_T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">"msggid"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msgInfo</span>;</span></span><br><span class="line">    msgInfo.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(msgInfo.mtext, <span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgsnd(msgid, &amp;msgInfo, <span class="built_in">strlen</span>(msgInfo.mtext), <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"msg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// msgrcv.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msgInfo</span>;</span></span><br><span class="line"></span><br><span class="line">    msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">"msggid"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;msgInfo,<span class="keyword">sizeof</span>(msgInfo));</span><br><span class="line">    ret = msgrcv(msgid, &amp;msgInfo, <span class="keyword">sizeof</span>(msgInfo.mtext), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"msgrcv"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mtype = %ld, mtext = %s\n"</span>, msgInfo.mtype, msgInfo.mtext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>信号是进程在运行过程中，由<strong>自身产生或由进程外部发过来</strong>的消息(事件)。信号是硬件中断的软件模拟(软中断)。每个信号用一个整型常量宏表示，以 SIG 开头，比如 SIGCHLD、SIGINT 等，它们在系统头文件 <code>&lt;signal.h&gt;</code>中定义，也可以通过在 shell 下键入 <code>kill –l</code> 查看信号列表，或者键入<code>man 7 signal</code> 查看更详细的说明。</p>
<p>由进程的某个操作产生的信号称为<strong>同步信号</strong>(synchronous signals)，例如除0；由像用户点击这样的进程外部事件产生的信号叫做<strong>异步信号</strong>。</p>
<p>进程接收到信号以后，可以有如下3种选择进行处理：</p>
<ul>
<li><strong>默认处理</strong>：这种处理<strong>通常会导致进程本身消亡</strong>。例如连接到终端的进程，如果按下 Ctrl+C 将导致内核向进程发送一个 SIGINT 信号，如果不做自定义处理，则终止进程的执行。有五种默认的处理方式：<strong>终止(Term)</strong>、<strong>忽略(Ign)</strong>、<strong>终止并产生core文件(Core)</strong>、<strong>暂停(Stop)</strong>、<strong>继续(Cont)</strong>。</li>
<li><strong>忽略信号</strong>：可以通过代码显示地忽略某个信号的处理，但注意<strong>有些信号是不能被忽略</strong>的。</li>
<li><strong>捕捉并处理</strong>：如果事先注册信号处理函数，当接收到信号时，将会由处理函数自动捕捉并处理信号。</li>
</ul>
<p>有两个信号既不能被忽略也不能被捕捉，<strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong>。即进程接收到这两个信号后，<strong>只能接受默认的处理方式，即终止程序</strong>。</p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个信号捕捉函数, 成功返回以前该信号的处理函数的地址, 否则返回 SIG_ERR</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 信号捕捉函数, 只有一个整型参数, 表示信号值</span></span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
<p><code>signum</code> 表示要捕捉的信号。</p>
<p><code>handler</code> 是函数指针，表示要对该信号进行捕捉的函数。也可以用 <strong>SIG_DEL</strong> 表示由系统缺省处理，<strong>SIG_IGN</strong> 表示忽略该信号不做任何处理。</p>
<h4 id="示例一：signal-的简单示例"><a href="#示例一：signal-的简单示例" class="headerlink" title="示例一：signal 的简单示例"></a>示例一：signal 的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d is coming\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(signal(SIGINT, sigFunc) == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">"signal"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在执行2号信号的时候接收到了3号信号，那么2号信号的处理<strong>会被打断</strong>转而去处理3号信号。但如果是此时再次发送2号信号，则3号信号的处理并不会被打断，这因为操作系统认为此时算是还在2号信号的处理流程中。</p>
<h4 id="示例二：关于signal机制的一个问题"><a href="#示例二：关于signal机制的一个问题" class="headerlink" title="示例二：关于signal机制的一个问题"></a>示例二：关于signal机制的一个问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig begin\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig %d is workd...\n"</span>, signum);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig end\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT, sigFunc);</span><br><span class="line">    signal(SIGQUIT, sigFunc);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行这个程序的时候，若我们键入 Ctrl+C 进入信号捕捉函数后，又连续按了好几次的 Ctrl+C，结果会发现，在当前信号捕捉函数执行结束后，只会再执行一次的信号捕捉函数。这是因为<strong>内核在存我们的信号的时候，是用一个位的集合</strong>。所以当我们发一个2号信号的时候，内核就把那个位置的数值置为1，然后调用信号捕捉函数的时候，再次把那个位置置为0。所以当我们发送很多次2号信号的时候，通过这个集合也只能知道<strong>有</strong>，但不能知道<strong>有几次</strong>。</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个信号处理函数, 成功返回0, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>signum</code> 为需要捕捉的信号。</p>
<p><code>act</code> 是一个结构体，里面包含信号处理函数地址、处理方式等信息。</p>
<p><code>oldact</code> 是一个传出参数，函数调用成功后，oldact 里面包含以前对 signum 的处理方式的信息，通常为 NULL。</p>
<p>这个 <code>sigaction</code> 类型的结构体有以下几个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);   <span class="comment">// 老类型的信号处理函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);     <span class="comment">// 新类型的信号处理函数指针</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;          <span class="comment">// 将要被阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;              <span class="comment">// 信号处理方式掩码</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>); <span class="comment">// 保留, 不使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sa_handler</code> 就是 <code>signal()</code> 使用的信号处理函数的方式。</p>
<p><code>sa_sigaction</code> 也是一个函数指针，这个函数的几个三个参数含义分别为：</p>
<ol>
<li>传入的信号</li>
<li>一个结构体指针，保存着发送信号方的各种信息，如uid、pid、fd等等等，具体在man手册里查看</li>
<li>保留，暂时没用，通常为NULL。</li>
</ol>
<p><code>sa_mask</code>  是将要被阻塞的信号集合。比如说我们在收到2号信号的时候，在信号处理函数中我们不希望其他的信号来打断我们的执行，就可以用到这个参数。对于这个参数的设定，我们有一系列的函数可以方便操作：</p>
<ul>
<li><code>int sigemptyset(sigset_t *set)</code>  ：清空信号集合 set</li>
<li><code>int sigfillset(sigset_t *set)</code> ：将所有信号填充进set</li>
<li><code>int sigaddset(sigset_t *set, int signum)</code> ：往 set 中添加信号 signum</li>
<li><code>int sigdelset(sigset_t *set, int signum)</code> ：从 set 中移除信号 signum</li>
<li><code>int sigismember(const sigset_t*set,intsignum)</code> ：判断signum是否包含在set中</li>
<li><code>int sigpending(sigset_t *set)</code> ：将被阻塞的信号集合由参数 set 指针返回，即查看有没有未处理的信号，可看示例三参考。</li>
</ul>
<p><code>sa_flags</code>  是一组掩码的合成值，每个都是一个位权限，指示信号处理时所应该采取的一些行为，各掩码的含义为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">掩码</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SA_SIGINFO</td>
<td style="text-align:center">指示结构体的信号处理函数指针是哪个有效，如果 sa_flags 包 含该掩码，则 sa_sigaction 指针有效，否则是 sa_handler 指针有效。</td>
</tr>
<tr>
<td style="text-align:center">SA_RESTART</td>
<td style="text-align:center">如果在发生信号时，程序正阻塞在某个系统调用，例如调用 read()函数，则在处理完毕信号后，接着从阻塞的系统返回。如果不指定该参数，中断处理完毕之后，read 函数读取失败。</td>
</tr>
<tr>
<td style="text-align:center">SA_NODEFER</td>
<td style="text-align:center">在处理信号时，如果又发生了新的信号，则立即进入新信号的处理，等新信号处理完毕后，再继续处理当前的信号， 即递规地处理。(不常用)不断重入，次数不丢失。</td>
</tr>
<tr>
<td style="text-align:center">SA_RESETHAND</td>
<td style="text-align:center">处理完毕要捕捉的信号后，将自动撤消信号处理函数的注册， 即必须再重新注册信号处理函数，才能继续处理接下来产生的信号。该选项不符合一般的信号处理流程，现已经被废弃。</td>
</tr>
<tr>
<td style="text-align:center">SA_RESTART</td>
<td style="text-align:center">在示例二中说明解释</td>
</tr>
</tbody>
</table>
</div>
<h4 id="示例一：sigaction的简单示例"><a href="#示例一：sigaction的简单示例" class="headerlink" title="示例一：sigaction的简单示例"></a>示例一：sigaction的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *p, <span class="keyword">void</span> *p1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d is coming\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    bzero(&amp;act, <span class="keyword">sizeof</span>(act));</span><br><span class="line"></span><br><span class="line">    act.sa_flags = SA_SIGINFO|SA_RESETHAND;</span><br><span class="line">    act.sa_sigaction = sigFunc;</span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigaction"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：sigaction与signal的不同"><a href="#示例二：sigaction与signal的不同" class="headerlink" title="示例二：sigaction与signal的不同"></a>示例二：sigaction与signal的不同</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *p, <span class="keyword">void</span> *p1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d is coming\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    bzero(&amp;act, <span class="keyword">sizeof</span>(act));</span><br><span class="line"></span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">// | SA_RESTART</span></span><br><span class="line">    act.sa_sigaction = sigFunc;</span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigaction"</span>);</span><br><span class="line"></span><br><span class="line">    ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret = %d, buf = %s\n"</span>, ret, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序执行这个程序的时候，<code>sigaction()</code> 注册的信号捕捉函数当遇到等待输入这类的阻塞时，若收到信号，则会使当前的阻塞失败，并去执行信号处理。但 <code>signal()</code> 则是将当前阻塞暂停，等信号处理结束后，再接着来这里继续等待阻塞。若希望 <code>sigaction()</code> 也采用同样的方式，则要将 <code>sa_flags</code> 添加 <strong>SA_RESTART</strong> 掩码。</p>
<h4 id="示例三：信号集的几个函数示例"><a href="#示例三：信号集的几个函数示例" class="headerlink" title="示例三：信号集的几个函数示例"></a>示例三：信号集的几个函数示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *p, <span class="keyword">void</span> *p1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d sig begin\n"</span>, signum);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span> pending;</span><br><span class="line">    <span class="comment">// 从进程中拿出未处理的信号</span></span><br><span class="line">    sigpending(&amp;pending);</span><br><span class="line">    <span class="keyword">if</span>(sigismember(&amp;pending, SIGQUIT)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGQUIT is pending\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGQUIT is not pending\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d sig end\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    bzero(&amp;act, <span class="keyword">sizeof</span>(act));</span><br><span class="line"></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = sigFunc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigaction"</span>);</span><br><span class="line">    ret = sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigaction"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例四：打印发送信号者的信息"><a href="#示例四：打印发送信号者的信息" class="headerlink" title="示例四：打印发送信号者的信息"></a>示例四：打印发送信号者的信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info_p, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig %d begin\n"</span>, signum);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %d, uid = %d\n"</span>, info_p-&gt;si_pid, info_p-&gt;si_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig %d end\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = sigFunc;</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞某个信号集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意区分在 <code>sigaction()</code> 中阻塞信号集合与用这个函数阻塞信号集合的区别：<code>sigaction()</code> 中设置的被阻塞信号集合<strong>只是针对于这个要处理的信号</strong>，而 <code>sigprocmask()</code> 则是<strong>全程阻塞</strong>，即所有所有的信号处理函数都忽略这个阻塞信号集。</p>
<p>也要明白在 <code>signal()</code> 中的忽略和阻塞的区别，忽略是直接<strong>无视这个信号</strong>，而阻塞是<strong>记住有这个信号</strong>，等到条件合适的时候再去处理。</p>
<p><code>how</code> ：有三个宏可以选择</p>
<ul>
<li>SIG_BLOCK：将 <code>set</code> 添加到进程原有的阻塞信号集合中</li>
<li>SIG_UNBLOCK：从进程原有的阻塞信号集合移除 <code>set</code> 中包含的信号</li>
<li>SIG_SETMASK：重新设置进程的阻塞信号集为 <code>set</code></li>
</ul>
<p><code>set</code>：为阻塞信号集，行为有参数 <code>how</code> 决定</p>
<p><code>oldset</code>：传出参数，存放进程原有的信号集，通常为 NULL</p>
<h4 id="示例一：使用sigprocmask设置阻塞信号集"><a href="#示例一：使用sigprocmask设置阻塞信号集" class="headerlink" title="示例一：使用sigprocmask设置阻塞信号集"></a>示例一：使用sigprocmask设置阻塞信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞 SIGINT 信号</span></span><br><span class="line">    ret = sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigprocmask"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10秒后解除阻塞</span></span><br><span class="line">    ret = sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sigprocmask"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将信号发送到其他进程, 其实就相当于将信号填到目标进程的待处理信号集中</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pid</code> ：将要接受信号的进程的 pid，注意根据 pid 的正负值有不同含义：</p>
<ul>
<li>pid &gt; 0：将信号发给ID为pid的进程</li>
<li>pid == 0： 将信号发送给与发送进程属于同一个<strong>进程组</strong>的所有进程</li>
<li>pid &lt; 0：将信号发送给<strong>进程组</strong> ID 等于 pid 绝对值的所有进程</li>
<li>pid == -1：将信号发送给该进程有权限发送的系统里的<strong>所有</strong>进程</li>
</ul>
<p><code>sig</code> ：为要发送的信号</p>
<h4 id="示例一：用kill实现类似kill指令"><a href="#示例一：用kill实现类似kill指令" class="headerlink" title="示例一：用kill实现类似kill指令"></a>示例一：用kill实现类似kill指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = kill(atoi(argv[<span class="number">2</span>]), atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"kill"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是进程/线程同步的一种方式，是可以用来<strong>保证两个或多个关键代码段不被并发调用</strong>。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。信号量主要会用到以下几个函数：</p>
<h3 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个信号量集或访问一个已存在的信号量集。</span></span><br><span class="line"><span class="comment">// 成功时，返回 一个称为信号量标识符的整数，semop 和 semctl 会使用它;出错时，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code> 是唯一标识一个信号量的关键字，如果为 <strong>IPC_PRIVATE</strong> ( 值为 0，创建一个只有创建者进程才可以访问的信号量，通常用于父子进程之间；非 0 值的 key(可以通 过 <code>ftok()</code> 函数获得)表示创建一个可以被多个进程共享的信号量。</p>
<p><code>nsems</code> 指定需要使用的信号量数目。如果是创建新集合，则必须制定 nsems。 如果引用一个现存的集合，则将 nsems 指定为 0。</p>
<p><code>semflg</code> 是一组标志，其作用与 open 函数的各种标志很相似。它低端的九个位是该信号量的权限，其作用相当于文件的访问权限。此外，它们还可以与键值 <strong>IPC_CREAT</strong> 按位或操作，以创建一个新的信号量。</p>
<h3 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来直接控制信号量信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code> 一般是由 <code>semget()</code> 返回的信号量标识符。</p>
<p><code>semnum</code> 为集合中信号量的编号，当要用到成组的信号量时，从 0 开始。一般取值为 0，表示这是第一个也是唯一的一个信号量。</p>
<p><code>cmd</code> 为执行的操作。通常为：</p>
<ul>
<li><strong>IPC_RMID</strong>：立即删除信号集，唤醒所有被阻塞的进程，第二个参数为 0</li>
<li><p><strong>IPC_STAT</strong>：查看信号集的信息，第二个参数为 0</p>
</li>
<li><p><strong>GETVAL</strong>：根据 semun 返回信号量的值，从0开始，第一个信号量编号 为0</p>
</li>
<li><p><strong>SETVAL</strong>：根据semun设定信号的值，从0开始，第一个信号量编号为0</p>
</li>
<li><p><strong>GETALL</strong>：获取所有信号量的值，第二个参数为 0，将所有信号的值存入 semun.array 中</p>
</li>
<li><p><strong>SETALL</strong>：将所有 semun.array 的值设定到信号集中，第二个参数为 0</p>
</li>
</ul>
<p><code>...</code> 是一个 <strong>union</strong> semun(需要由程序员自己定义)，它至少包含以下几个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun&#123;</span><br><span class="line">    <span class="comment">// 通常情况仅使用 val, 给 val 赋值为 1 (0表示加锁, 1表示解锁)</span></span><br><span class="line">    <span class="keyword">int</span> val;                  <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>     <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;    <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中结构体 <code>semid_ds</code> 的数据成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>     <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_otime;    <span class="comment">/* Last semop time */</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_ctime;    <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   sem_nsems;    <span class="comment">/* No. of semaphores in set */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>semid_ds</code> 中的结构体 <code>ipc_perm</code> 的数据成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span>       __key; <span class="comment">/* Key supplied to semget(2) */</span></span><br><span class="line">    <span class="keyword">uid_t</span>       uid;   <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>       gid;   <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="keyword">uid_t</span>       cuid;  <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="keyword">gid_t</span>       cgid;  <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> mode;  <span class="comment">/* Permissions */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> __seq; <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例一：SETALL与GETALL的简单示例"><a href="#示例一：SETALL与GETALL的简单示例" class="headerlink" title="示例一：SETALL与GETALL的简单示例"></a>示例一：SETALL与GETALL的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semArrId;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[<span class="number">2</span>] = &#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    semArrId = semget(<span class="number">1000</span>, <span class="number">2</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semArrId, <span class="number">-1</span>, <span class="string">"semget"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将信号集内的两个信号量分别填 5 和 10</span></span><br><span class="line">    ret = semctl(semArrId, <span class="number">0</span>, SETALL, arr);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"semctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把信号集里的两个信号量填到数组 arr 中</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">    ret = semctl(semArrId, <span class="number">0</span>, GETALL, arr);</span><br><span class="line">   </span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"semctl"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get val, arr[0] = %d, arr[1] = %d\n"</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：IPC-STAT的简单示例"><a href="#示例二：IPC-STAT的简单示例" class="headerlink" title="示例二：IPC_STAT的简单示例"></a>示例二：IPC_STAT的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semArrId;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    semArrId = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semArrId, <span class="number">-1</span>, <span class="string">"semget"</span>);</span><br><span class="line"></span><br><span class="line">    ret = semctl(semArrId, <span class="number">0</span>, IPC_STAT, &amp;buf);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"semctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid = %d, mode = %o, nsems = %ld\n"</span>, buf.sem_perm.uid,</span><br><span class="line">           buf.sem_perm.mode, buf.sem_nsems);</span><br><span class="line"></span><br><span class="line">    buf.sem_perm.mode = <span class="number">0666</span>;</span><br><span class="line"></span><br><span class="line">    ret = semctl(semArrId, <span class="number">0</span>, IPC_SET, &amp;buf);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"semctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于改变信号量对象中各个信号量的状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> num_sops)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code> 是由 semget 返回的信号量标识符。</p>
<p><code>sops</code> 是指向一个结构体数组的指针，这个结构体内至少包含以下几个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num;  <span class="comment">//操作信号量在信号量集合中的编号，第一个信号量的编号是0</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;   <span class="comment">//sem_op 成员的值是信号量在一次操作中需要改变的。-1 是p操作，+1是v操作</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg;  <span class="comment">//通常设为:SEM_UNDO，程序结束，信号量为 semop 调用前的值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>num_sops</code> 是第二个参数sops指向的结构体数组一共有多少个元素。</p>
<h3 id="示例一：通过信号量使两个进程对同一块地址各加一千万"><a href="#示例一：通过信号量使两个进程对同一块地址各加一千万" class="headerlink" title="示例一：通过信号量使两个进程对同一块地址各加一千万"></a>示例一：通过信号量使两个进程对同一块地址各加一千万</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> semArrId;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sopp</span>, <span class="title">sopv</span>;</span></span><br><span class="line">    sopp.sem_num = <span class="number">0</span>;</span><br><span class="line">    sopp.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sopp.sem_flg = SEM_UNDO;</span><br><span class="line">  </span><br><span class="line">    sopv.sem_num = <span class="number">0</span>;</span><br><span class="line">    sopv.sem_op = <span class="number">1</span>;</span><br><span class="line">    sopv.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号量</span></span><br><span class="line">    semArrId = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semArrId, <span class="number">-1</span>, <span class="string">"semget"</span>);</span><br><span class="line">    <span class="comment">// 设置共享内存</span></span><br><span class="line">    shmid = shmget(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">"shmget"</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">int</span> *)<span class="number">-1</span>, <span class="string">"shmat"</span>);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置信号量中0号信号量的值为1，即解锁</span></span><br><span class="line">    ret = semctl(semArrId, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"semctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            semop(semArrId, &amp;sopp, <span class="number">1</span>);</span><br><span class="line">            *p += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            semop(semArrId, &amp;sopv, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            semop(semArrId, &amp;sopp, <span class="number">1</span>);</span><br><span class="line">            *p += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            semop(semArrId, &amp;sopv, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：通过信号量实现生产者消费者模型"><a href="#示例二：通过信号量实现生产者消费者模型" class="headerlink" title="示例二：通过信号量实现生产者消费者模型"></a>示例二：通过信号量实现生产者消费者模型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semArrId;</span><br><span class="line">    <span class="comment">// arr[0] 表示生产者的资源  arr[1] 表示消费者的资源</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[<span class="number">2</span>] = &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sopp</span>, <span class="title">sopv</span>;</span></span><br><span class="line"></span><br><span class="line">    semArrId = semget(<span class="number">1000</span>, <span class="number">2</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semArrId, <span class="number">-1</span>, <span class="string">"semget"</span>);</span><br><span class="line"></span><br><span class="line">    semctl(semArrId, <span class="number">0</span>, SETALL, arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程做消费者</span></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            sopp.sem_num = <span class="number">1</span>;</span><br><span class="line">            sopp.sem_op = <span class="number">-1</span>;</span><br><span class="line">            sopp.sem_flg = SEM_UNDO;</span><br><span class="line">            sopv.sem_num = <span class="number">0</span>;</span><br><span class="line">            sopv.sem_op = <span class="number">1</span>;</span><br><span class="line">            sopv.sem_flg = SEM_UNDO;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"---------------child---------------\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"space num = %d, productor num = %d\n"</span>,</span><br><span class="line">                   semctl(semArrId, <span class="number">0</span>, GETVAL), semctl(semArrId, <span class="number">1</span>, GETVAL));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 产品个数 -1</span></span><br><span class="line">            semop(semArrId, &amp;sopv, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"consume sucess\n"</span>);</span><br><span class="line">            <span class="comment">// 仓库个数 +1</span></span><br><span class="line">            semop(semArrId, &amp;sopp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"space num = %d, productor num = %d\n"</span>,</span><br><span class="line">                   semctl(semArrId, <span class="number">0</span>, GETVAL), semctl(semArrId, <span class="number">1</span>, GETVAL));</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sopp.sem_num = <span class="number">0</span>;</span><br><span class="line">            sopp.sem_op = <span class="number">-1</span>;</span><br><span class="line">            sopp.sem_flg = SEM_UNDO;</span><br><span class="line">            sopv.sem_num = <span class="number">1</span>;</span><br><span class="line">            sopv.sem_op = <span class="number">1</span>;</span><br><span class="line">            sopv.sem_flg = SEM_UNDO;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"---------------parent---------------\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"space num = %d, productor num = %d\n"</span>,</span><br><span class="line">                   semctl(semArrId, <span class="number">0</span>, GETVAL), semctl(semArrId, <span class="number">1</span>, GETVAL));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 仓库个数 -1</span></span><br><span class="line">            semop(semArrId, &amp;sopv, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"product sucess\n"</span>);</span><br><span class="line">            <span class="comment">// 产品个数 +1</span></span><br><span class="line">            semop(semArrId, &amp;sopp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"space num = %d, productor num = %d\n"</span>,</span><br><span class="line">                   semctl(semArrId, <span class="number">0</span>, GETVAL), semctl(semArrId, <span class="number">1</span>, GETVAL));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>进程是资源分配的基本单位</strong>。每个进程有自己的数据段、代码段和堆栈段。这就造成进程在进行切换等操作时都需要有比较负责的上下文切换等动作。为了进一步减少处理器的空转时间支持多处理器和减少上下文切换开销，也就出现了线程，<strong>线程是CPU调度的最小单位</strong>。我们在Linux下使用的是<strong>nptl</strong>线程库，注意在编译的时候要加上 <code>-pthread</code> 。</p>
<p>线程是在共享内存空间中并行执行的多道执行路径，是一个更加接近于执行体的概念，拥有独立的执行序列，是进程的基本调度单元，每个进程至少都有一个 main 线程。它与同进程中的其他线程共享进程空间(堆、代码、数据、文件描述符、信号等），<strong>只拥有自己的栈空间，大大减少了上下文切换的开销</strong>。</p>
<p>线程和进程在使用上各有优缺点：<strong>线程执行开销小，占用的 CPU 少，线程之间的切换快，但不利于资源的管理和保护，只要一个线程崩了，整个进程也会一起崩溃，而多进程正相反</strong>。从可移植性来讲，多进程的可移植性要好些。</p>
<p>同进程一样，线程也将相关的变量值放在线程控制表内。一个进程可以有多个线程，也就是有多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。要注意的是，由于线程共享了进程的资源和地址空间，因此，<strong>任何线程对系统资源的操作都会给其他线程带来影响</strong>。</p>
<p>当在bash中要查看某个进程中的多个线程时，要用 <code>ps -elLf | grep name</code> </p>
<h2 id="创建与退出"><a href="#创建与退出" class="headerlink" title="创建与退出"></a>创建与退出</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建线程实际上就是<strong>确定调用该线程函数的入口点</strong>，线程的创建采用函数 <code>pthread_create()</code> ，在线程创建以后，就开始运行相关的线程函数。</p>
<p>线程有两种退出方式，其一是等待线程函数运行完后的<strong>自然退出</strong>，其二是使用函数 <code>pthread_exit()</code> ，这是线程的<strong>主动退出</strong>行为。要注意的是，在线程函数中不能随意使用 <code>exit()</code> 退出进行出错处理，因为 <code>exit()</code> 的作用是使调用的<strong>进程</strong>终止，而往往一个进程有很多线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建进程, 成功返回0, 失败返回错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">pthread_attr_t</span> * attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> * arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>thread</code> 是<strong>传出参数</strong>，保存新线程的标识</p>
<p><code>attr</code> 是结构体指针，结构中的元素分别指定新线程的<strong>运行属性</strong>，attr 可以用 <code>pthread_attr_init()</code> 等设置各成员的值，但通常传入为 NULL 即可</p>
<p><code>start_routine</code> 是函数指针，指向新线程的入口点函数，线程入口点函数带有一个 <code>void *</code> 的参数，其值由该函数的第四个参数传入</p>
<p><code>arg</code> 用于接收<code>start_routine(void *)</code> 的参数，可以为 NULL，表示不传递</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程退出, 其参数可以被其它线程用 pthread_join 函数捕获</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>retval</code> 可以被其它线程用 <code>pthread_join()</code> 函数捕获</p>
<p>要注意在子线程中 <code>return</code> 、 <code>pthread_exit()</code> 和  <code>exit()</code> 的区别，<code>return</code> 只会返回不会退出线程，<code>pthread_exit()</code> 退出当前线程，而 <code>exit()</code> 是直接退出进程，这往往是不合理的。</p>
<h4 id="示例一：创建并退出线程"><a href="#示例一：创建并退出线程" class="headerlink" title="示例一：创建并退出线程"></a>示例一：创建并退出线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am print\n"</span>);</span><br><span class="line">    <span class="comment">// 如果是用 return, 则还是会打印 "...after print\n"</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">    print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child, after print\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待退出"><a href="#等待退出" class="headerlink" title="等待退出"></a>等待退出</h2><p>因为同一进程的多个线程共享进程空间，因此在某个线程退出后他的资源不会自己释放。在多进程中，父进程使用 <code>wait()</code> 来回收子进程资源，而在多线程中，主线程则使用 <code>pthread_join()</code> 来回收子线程，这是一个<strong>线程阻塞函数</strong>，可以用于将当前线程挂起，一直等待到被等待的线程结束为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> th, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>th</code> 指定等待线程</p>
<p><code>thread_return</code> 是一个<strong>传出参数</strong>，接收线程函数的返回值。如果线程通过调用 <code>pthread_exit()</code> 终止，则 <code>pthread_exit()</code> 中的参数相当于其中返回值。但如果线程是<strong>被取消</strong>的，则传出参数会得到 -1。</p>
<h3 id="示例一：创建并等待退出"><a href="#示例一：创建并等待退出" class="headerlink" title="示例一：创建并等待退出"></a>示例一：创建并等待退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread, get %s\n"</span>, (<span class="keyword">char</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数放在堆中</span></span><br><span class="line">    <span class="keyword">char</span> *pArg = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(pArg, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, pArg);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程</span></span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：等待退出并接收指针返回值"><a href="#示例二：等待退出并接收指针返回值" class="headerlink" title="示例二：等待退出并接收指针返回值"></a>示例二：等待退出并接收指针返回值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)p , <span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">    pthread_exit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *pRet;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(pthid, (<span class="keyword">void</span>**)&amp;pRet);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread, join get: %s\n"</span>, pRet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这种在子线程中申请堆空间并返回指针的用得并不多，常用的还是下面的那种返回子线程成功还是失败的例子。</p>
<h3 id="示例三：等待退出并接收整型返回值"><a href="#示例三：等待退出并接收整型返回值" class="headerlink" title="示例三：等待退出并接收整型返回值"></a>示例三：等待退出并接收整型返回值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 注意这里一定要用 long, 因为一级指针的长度和long一样</span></span><br><span class="line">    <span class="keyword">long</span> threadRet;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(pthid, (<span class="keyword">void</span>**)&amp;threadRet);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread, join get: %ld\n"</span>, threadRet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>线程也可以被其它线程杀掉，在 Linux 中的说法是一个线程被另一个线程取消(cancel)，线程取消的方法是一个线程向目标线程发 cancel 信号，如何处理这个信号由目标线程决定，一般是运行到取消点时，就会触发这个信号。从设计的角度来看，一个线程取消另一个线程不是一种好的风格，所以在实际应用中需谨慎使用。</p>
<p>一个线程如果被取消了，则用 <code>pthread_join()</code> 得到的值为 -1</p>
<h2 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h2><p>当线程正常或异常终止时，都存在资源释放的问题。清理函数就是为了保证在任何情况下，线程都能够正常的清理自己的资源，<strong>特别是锁资源</strong>。</p>
<p>最经常出现的情形是资源独占锁的使用：线程为了访问临界共享资源而为其加上锁，但在访问过程中该线程被外界取消，或者发生了中断，则该临界资源将永远处于锁定状态得不到释放。外界取消操作是不可预见的，因此的确需要一个机制来简化用于资源释放的编程。</p>
<p>在 POSIX 线程 API 中提供了一个 <code>pthread_cleanup_push()/pthread_cleanup_pop()</code> 函数对用于自动释放资源，从 <code>pthread_cleanup_push()</code> 的调用点到 <code>pthread_cleanup_pop()</code> 之间的程序段中的终止动作都将执行 <code>pthread_cleanup_push()</code> 所指定的清理函数。API 定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span></span><br></pre></td></tr></table></figure>
<p><code>pthread_cleanup_push()</code> 宏带有一个”{“，而 <code>pthread_cleanup_pop()</code> 宏带有一个”}”，因此这两个函数必须成对出现，且必须位于程序的同一级别的代码段中才能通过编译。</p>
<p><strong>清理函数被执行的三种情况</strong>：</p>
<ul>
<li>线程被取消</li>
<li>线程通过 <code>pthread_exit()</code> 退出</li>
<li>遇到 <code>pthread_cleanup_pop(1)</code> 弹出清理函数。（若是 0，则是弹出不执行）</li>
</ul>
<h3 id="示例一：清理函数简单示例"><a href="#示例一：清理函数简单示例" class="headerlink" title="示例一：清理函数简单示例"></a>示例一：清理函数简单示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free success\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 将清理函数压栈</span></span><br><span class="line">    pthread_cleanup_push(cleanup, p);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">long</span> threadRet;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_cancel(pthid);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_cancel"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(pthid, (<span class="keyword">void</span>**)&amp;threadRet);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_join"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread %ld\n"</span>, threadRet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：清理函数的执行顺序"><a href="#示例二：清理函数的执行顺序" class="headerlink" title="示例二：清理函数的执行顺序"></a>示例二：清理函数的执行顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am cleanup %ld\n"</span>, (<span class="keyword">long</span>)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">long</span> threadRet;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pthid, (<span class="keyword">void</span>**)&amp;threadRet);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"threadRet = %ld\n"</span>, threadRet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候，我们需要在清理函数前先释放一块内存，但这时若线程被取消掉了，就会执行一次清理函数。因为那块内存之前已经被释放过一次，所以在这次清理函数时就会使程序崩溃。因此我们可以使用一对清理函数来代替 <code>free()</code> 以避免这种情况。</p>
<h3 id="示例三：使用清理函数进行解锁"><a href="#示例三：使用清理函数进行解锁" class="headerlink" title="示例三：使用清理函数进行解锁"></a>示例三：使用清理函数进行解锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;Data_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_unlock((<span class="keyword">pthread_mutex_t</span>*)p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlock success\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t* pArg = (Data_t*)p;</span><br><span class="line">    pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">    pthread_cleanup_push(cleanup, &amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child lock success\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 最好由清理函数来负责解锁, 这样即使被cancel, 也能够解锁</span></span><br><span class="line">    <span class="comment">// pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"you can't see me\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid1, pthid2;</span><br><span class="line">    <span class="keyword">long</span> threadRet;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;pthid1, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line">    pthread_create(&amp;pthid2, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line"></span><br><span class="line">    pthread_cancel(pthid1);</span><br><span class="line">    pthread_cancel(pthid2);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid2, (<span class="keyword">void</span>**)&amp;threadRet);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthid2 ret = %ld\n"</span>, threadRet);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid1, (<span class="keyword">void</span>**)&amp;threadRet);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthid1 ret = %ld\n"</span>, threadRet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的互斥"><a href="#线程的互斥" class="headerlink" title="线程的互斥"></a>线程的互斥</h2><p>在Posix Thread中定义了一套专门用于线程互斥的mutex函数。mutex是一种简单的加锁的方法来控制对共享资源的存取，这个互斥锁只有上锁和解锁两种状态。</p>
<p>锁的存在的原因是因为多个线程共用进程的资源，当一个线程使用临界资源时，需要加上锁以防止另外的线程对它进行访问，<strong>实现资源的独占</strong>。在一个时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望上锁一个已经上锁了的互斥锁，则该线程就会挂起，直到上锁的线程释放掉互斥锁为止。</p>
<h3 id="锁的创建与注销"><a href="#锁的创建与注销" class="headerlink" title="锁的创建与注销"></a>锁的创建与注销</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"><span class="comment">// 注销一个互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="锁的操作"><a href="#锁的操作" class="headerlink" title="锁的操作"></a>锁的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_mutex_lock</code>：不论哪种类型的锁，都不可能被两个不同的线程同时得到，而必须等待解锁。在同一进程中的线程，如果加锁后没有解锁，则任何其他线程都无法再获得锁。</p>
<ul>
<li>普通锁类型，解锁者可以是同进程内任何线程</li>
<li>检错锁则必须由加锁者解锁才有效，否则返回 EPERM</li>
<li>嵌套锁，文档和实现要求必须由加锁者解锁，但实验结果表明并没有这种限制， 这个不同目前还没有得到解释</li>
</ul>
<p><code>pthread_mutex_unlock</code>：根据不同的锁类型，实现不同的行为</p>
<ul>
<li>快速锁，解除锁定</li>
<li>递规锁，使锁上的引用计数减 1</li>
<li>检错锁，如果锁是当前线程锁定的，则解除锁定，否则什么也不做</li>
</ul>
<p><code>pthread_mutex_trylock</code>：与 <code>pthread_mutex_lock()</code> 类似，不同的是<strong>在锁已经被占据时返回 EBUSY而不是挂起等待</strong>。</p>
<h4 id="示例一：trylock的机制"><a href="#示例一：trylock的机制" class="headerlink" title="示例一：trylock的机制"></a>示例一：trylock的机制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;Data_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t* pArg = (Data_t *)p;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_mutex_trylock(&amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"trylock: %s\n"</span>, strerror(ret));</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child lock success\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;threadInfo.mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread lock success\n"</span>);</span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：使用互斥锁两个线程各加2000万"><a href="#示例二：使用互斥锁两个线程各加2000万" class="headerlink" title="示例二：使用互斥锁两个线程各加2000万"></a>示例二：使用互斥锁两个线程各加2000万</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;Data_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t *pVal = (Data_t *)p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pVal-&gt;mutex);</span><br><span class="line">        pVal-&gt;val += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;pVal-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    ret = pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_mutex_init"</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">"pthread_create"</span>);</span><br><span class="line"></span><br><span class="line">    threadInfo.val = <span class="number">0</span>;</span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;threadInfo.mutex);</span><br><span class="line">        threadInfo.val += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;threadInfo.mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待子线程</span></span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);  </span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread, %d + %d = %d\n"</span>, N, N, threadInfo.val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use time %ld\n"</span>, (end.tv_sec-start.tv_sec)*<span class="number">1000000</span>+end.tv_usec-start.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁的属性"><a href="#锁的属性" class="headerlink" title="锁的属性"></a>锁的属性</h3><p>互斥锁的属性在创建锁的时候指定，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同，也就是是否阻塞等待。有三个值可供选择：</p>
<ul>
<li><p><strong>PTHREAD_MUTEX_TIMED</strong>：<strong>普通锁</strong>，这是缺省值，即用NULL是即是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个阻塞等待队列，并在解锁后按优先级获得锁，这种锁策略保证了资源分配的公平性</p>
</li>
<li><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>：<strong>嵌套锁</strong>，允许<strong>同一个线程</strong>对同一个锁成功获得多次，并通过多次 unlock 解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争</p>
</li>
<li><strong>PTHREAD_MUTEX_ERRORCHECK</strong>：<strong>检错锁</strong>，如果<strong>同一个线程请求同一个锁，则返回 EDEADLK</strong>， 否则与 PTHREAD_MUTEX_TIMED 类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。如果是普通锁，在连续加锁两次的情况下，就会造成死锁。</li>
<li><strong>PTHREAD_MUTEX_SHARED</strong>：进程间可以共享使用一把锁</li>
</ul>
<p>注意：前三个属性是在 <code>pthread_mutex_settype()</code> 函数中设置，而进程间共享一把锁在用 <code>pthread_mutexattr_setpshared</code> 设置，具体可以看下面的示例</p>
<h4 id="示例一：嵌套锁与检错锁的创建"><a href="#示例一：嵌套锁与检错锁的创建" class="headerlink" title="示例一：嵌套锁与检错锁的创建"></a>示例一：嵌套锁与检错锁的创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个嵌套锁或检错锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line"></span><br><span class="line">pthread_mutexattr_init(&amp;mutexattr);</span><br><span class="line"><span class="comment">// 若把PTHREAD_MUTEX_RECURSIVE改成PTHREAD_MUTEX_ERRORCHECK即为检错锁</span></span><br><span class="line">pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;mutexattr);</span><br></pre></td></tr></table></figure>
<h4 id="示例二：在进程使用互斥锁"><a href="#示例二：在进程使用互斥锁" class="headerlink" title="示例二：在进程使用互斥锁"></a>示例二：在进程使用互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在两个进程中实现互加2000万</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;Data_t, *pData_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    pData_t p;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mattr;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">"shmget"</span>);</span><br><span class="line">    p = (pData_t)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (pData_t)<span class="number">-1</span>, <span class="string">"shmat"</span>);</span><br><span class="line"></span><br><span class="line">    p-&gt;val = <span class="number">0</span>;</span><br><span class="line">    ret = pthread_mutexattr_init(&amp;mattr);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_mutexattr_init: %s"</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;p-&gt;mutex, &amp;mattr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;p-&gt;mutex);</span><br><span class="line">            p-&gt;val += <span class="number">1</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;p-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;p-&gt;mutex);</span><br><span class="line">            p-&gt;val += <span class="number">1</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;p-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, N, N, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>同步又称为直接制约关系，是指多个线程为了合作完成某一个任务，必须按照规定的某种先后顺序来运行。<strong>条件变量</strong>是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待条件变量的条件成立而挂起；另一个线程使条件成立(给出条件成立信号)。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。</p>
<h3 id="创建与退出-1"><a href="#创建与退出-1" class="headerlink" title="创建与退出"></a>创建与退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>cond_attr</code> 虽然POSIX标准中定义了属性，但未实现，所以<strong>通常为 NULL</strong>，且被忽略</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有在<strong>没有线程在该条件变量上等待的时候，才能注销这个条件变量</strong>，否则返回 EBUSY</p>
<h3 id="等待和激发"><a href="#等待和激发" class="headerlink" title="等待和激发"></a>等待和激发</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，<strong>等待行为内蕴含了一次解锁与加锁的过程</strong>，可以将其分成上下两部分：</p>
<ul>
<li><p>上半部：排队、解锁、睡眠</p>
</li>
<li><p>下半部：唤醒、加锁</p>
</li>
</ul>
<p>可以看例题三。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在多个等待线程时, 按入队顺序激活其中一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活所有等待线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="示例一：条件变量的简单使用"><a href="#示例一：条件变量的简单使用" class="headerlink" title="示例一：条件变量的简单使用"></a>示例一：条件变量的简单使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;Data_t, *pData_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pData_t pArg = (pData_t)p;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="comment">// 子线程等待条件变量</span></span><br><span class="line">    pthread_cond_wait(&amp;pArg-&gt;cond, &amp;pArg-&gt;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread, I wake up\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 条件变量的初始化</span></span><br><span class="line">    pthread_cond_init(&amp;threadInfo.cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使条件变量成立</span></span><br><span class="line">    pthread_cond_signal(&amp;threadInfo.cond);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>使条件变量成立是一瞬间的行为</strong>，因此如果在这段代码中主线程未 <code>sleep(1)</code> 等待子线程运行到等待条件变量成立时，就会导致子线程不能收到条件成立从而死锁。</p>
<h4 id="示例二：多线程使用条件变量需注意死锁"><a href="#示例二：多线程使用条件变量需注意死锁" class="headerlink" title="示例二：多线程使用条件变量需注意死锁"></a>示例二：多线程使用条件变量需注意死锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;Data_t, *pData_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_unlock((<span class="keyword">pthread_mutex_t</span>*)p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlock success\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pData_t pArg = (pData_t)p;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">    pthread_cleanup_push(cleanup, &amp;pArg-&gt;mutex);    <span class="comment">// 防止在wait时被取消而导致死锁</span></span><br><span class="line">    <span class="comment">// 子线程等待条件变量</span></span><br><span class="line">    pthread_cond_wait(&amp;pArg-&gt;cond, &amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="comment">// pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">// 如果用上面的函数, 则有可能在下面运行时被取消导致重复清理</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread, I wake up\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid1, pthid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 条件变量的初始化</span></span><br><span class="line">    pthread_cond_init(&amp;threadInfo.cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthid1, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line">    pthread_create(&amp;pthid2, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line"></span><br><span class="line">    pthread_cancel(pthid1);</span><br><span class="line">    pthread_cancel(pthid2);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pthid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例三：wait包含了一次解锁与加锁"><a href="#示例三：wait包含了一次解锁与加锁" class="headerlink" title="示例三：wait包含了一次解锁与加锁"></a>示例三：wait包含了一次解锁与加锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;Data_t, *pData_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_unlock((<span class="keyword">pthread_mutex_t</span>*)p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlock success\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pData_t pArg = (pData_t)p;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">    pthread_cleanup_push(cleanup, &amp;pArg-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start wait\n"</span>);</span><br><span class="line">    pthread_cond_wait(&amp;pArg-&gt;cond, &amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end wait\n"</span>);</span><br><span class="line">  </span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t threadInfo;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid1, pthid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;threadInfo.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 条件变量的初始化</span></span><br><span class="line">    pthread_cond_init(&amp;threadInfo.cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthid1, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line">    pthread_create(&amp;pthid2, <span class="literal">NULL</span>, threadFunc, &amp;threadInfo);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 使条件变量成立</span></span><br><span class="line">    pthread_cond_signal(&amp;threadInfo.cond);</span><br><span class="line">    pthread_cond_signal(&amp;threadInfo.cond);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pthid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>pthread_cond_wait()</code> 内是有<strong>解锁并加锁</strong>的行为，因此运行这个程序时我们会发现两个线程都在 <code>start wait</code> 的阶段。</p>
<h4 id="示例四：售票并且子线程补一次票"><a href="#示例四：售票并且子线程补一次票" class="headerlink" title="示例四：售票并且子线程补一次票"></a>示例四：售票并且子线程补一次票</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tickets;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;Data_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">saleFunc1</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t *pArg = (Data_t*)p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">        <span class="keyword">if</span>(pArg-&gt;tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pArg-&gt;tickets--;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"saler1: %d\n"</span>, pArg-&gt;tickets);</span><br><span class="line">            <span class="keyword">if</span>(pArg-&gt;tickets == <span class="number">0</span>) &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pArg-&gt;cond);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">saleFunc2</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t *pArg = (Data_t*)p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">        <span class="keyword">if</span>(pArg-&gt;tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pArg-&gt;tickets--;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"saler2: %d\n"</span>, pArg-&gt;tickets);</span><br><span class="line">            <span class="keyword">if</span>(pArg-&gt;tickets == <span class="number">0</span>) &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pArg-&gt;cond);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sellFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data_t *pArg = (Data_t*)p;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;pArg-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span>(pArg-&gt;tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;pArg-&gt;cond, &amp;pArg-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pArg-&gt;tickets = <span class="number">20</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;pArg-&gt;mutex);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> saler1, saler2;</span><br><span class="line">    <span class="keyword">pthread_t</span> seller;</span><br><span class="line"></span><br><span class="line">    Data_t ticket;</span><br><span class="line"></span><br><span class="line">    ticket.tickets = <span class="number">20</span>;</span><br><span class="line">    pthread_mutex_init(&amp;ticket.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;ticket.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;saler1, <span class="literal">NULL</span>, saleFunc1, &amp;ticket);</span><br><span class="line">    pthread_create(&amp;saler2, <span class="literal">NULL</span>, saleFunc2, &amp;ticket);</span><br><span class="line">    pthread_create(&amp;seller, <span class="literal">NULL</span>, sellFunc, &amp;ticket);</span><br><span class="line"></span><br><span class="line">    pthread_join(saler1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(saler2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(seller, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果一个函数能够安全的<strong>同时被多个线程调用而得到正确的结果</strong>，就可以说这个函数是线程安全的。简单来说线程安全就是多个线程并发同一段代码时，不会出现不同的结果。</p>
<p>判断是不是线程安全函数的一个重要依据是：<strong>函数是否使用了全局变量或静态局部变量</strong>，即共享的数据。</p>
<p>注意<strong>可重入函数只是线程安全函数的一个子集</strong>，比如有这么一个函数，他使用局部静态变量 <code>a</code>，每次调用 <code>a</code> 自增1，若加了锁，那么他就是不可重入的但确是线程安全的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* p1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    time(&amp;now);</span><br><span class="line">    <span class="keyword">char</span> *p = ctime(&amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread, p = %s\n"</span>, p);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread, p = %s\n"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    time(&amp;now);</span><br><span class="line">    <span class="keyword">char</span> *p = ctime(&amp;now);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread, p = %s\n"</span>, p);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行这个程序的时候，会发现子线程中打印的两次时间居然是不一样的。这就是因为 <code>ctime()</code> 是一个不安全函数，因为子线程中指针时一个静态变量，所以此时当在主线程中使用 <code>ctime()</code> 的时候就会使用同一片内存空间，这就导致了我们看到的结果。为了改变这种现象，我们可以使用线程安全函数，这类函数往往是在原有的函数名后面加一个 <code>_r</code></p>
<h2 id="线程属性（了解）"><a href="#线程属性（了解）" class="headerlink" title="线程属性（了解）"></a>线程属性（了解）</h2><h3 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功 0，错误-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>attr</code> 传出参数，表示线程属性，后面的线程属性设置函数都会用到</p>
<h3 id="设置绑定属性"><a href="#设置绑定属性" class="headerlink" title="设置绑定属性"></a>设置绑定属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setscope</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, init scope)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>attr</code> 线程属性</p>
<p><code>scope</code> <strong>PTHREAD_SCOPE_SYSTEM</strong>(绑定)、<strong>PTHREAD_SCOPE_PRCESS</strong>(非绑定)</p>
<h3 id="设置分离属性"><a href="#设置分离属性" class="headerlink" title="设置分离属性"></a>设置分离属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, init detachstate)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>attr</code> 线程属性</p>
<p><code>detachstate</code> <strong>PTHREAD_CREAT_DETACHED</strong>(分离)、<strong>PTHREAD_CREAT_JOINABLE</strong>(非分离)</p>
<h3 id="获取与设置线程优先级"><a href="#获取与设置线程优先级" class="headerlink" title="获取与设置线程优先级"></a>获取与设置线程优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取线程优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getschedparam</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, struct sched_param *param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程优先级</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setschedparam</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, struct sched_param *param)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>attr</code> 线程属性</p>
<p><code>param</code> 线程优先级</p>
<h4 id="示例一：通过设置属性达到线程分离"><a href="#示例一：通过设置属性达到线程分离" class="headerlink" title="示例一：通过设置属性达到线程分离"></a>示例一：通过设置属性达到线程分离</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 当设置线程属性为分离时, 该线程不能被join</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;pthid, &amp;attr, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(pthid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_join:%s\n"</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread, ret = %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><h3 id="socket信息数据结构"><a href="#socket信息数据结构" class="headerlink" title="socket信息数据结构"></a>socket信息数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family;          <span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;   <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>       <span class="comment">/* IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];     <span class="comment">/* 填充 0 以保持与旧结构体同样大小 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;    <span class="comment">/* 32 位 IPv4 地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数据存储优先顺序的转换"><a href="#数据存储优先顺序的转换" class="headerlink" title="数据存储优先顺序的转换"></a>数据存储优先顺序的转换</h3><p>内存的低地址存储数据的低字节，低地址存储数据的低字节的方式叫<strong>小端模式</strong>。内存的高地址存储数据的低字节，低地址存储数据高字节的方式称为<strong>大端模式</strong>。</p>
<p>例如对于内存中存放的数 <code>0x12345678</code> 来说：</p>
<ul>
<li>大端模式存放的，则其真实的数是：<code>0x12345678</code></li>
<li>小端模式存放的，则其真实的数是：<code>0x78563412</code></li>
</ul>
<p>某个系统所采用的字节序称为主机字节序，他既可能是小端模式的，也可能是大端模式的，而<strong>网络字节序都是大端模式</strong>的。所以要把主机字节序和网络字节序对应起来的话，需要提前转换这两个字节存储顺序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     h 代表 host, n 代表 network, s 代表 short, l 代表 long。</span></span><br><span class="line"><span class="comment">     通常 16 位的 IP 端口号用 s 代表, 而 IP 地址用 l 来代表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure>
<h4 id="示例一：查看本机是大端还是小端模式"><a href="#示例一：查看本机是大端还是小端模式" class="headerlink" title="示例一：查看本机是大端还是小端模式"></a>示例一：查看本机是大端还是小端模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若输出 78 , 则表明使用的是小端模式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, *(<span class="keyword">char</span>*)p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="地址格式转化"><a href="#地址格式转化" class="headerlink" title="地址格式转化"></a>地址格式转化</h3><p>通常用户在表达地址时采用的是<strong>点分十进制</strong>表示的数值， 而在 socket 编程中使用的则是 32 位的网络字节序的<strong>二进制值</strong>，这就需要将这两个数值进行转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将点分十进制数的IP地址转换成为网络字节序的32位二进制数值。成功返回1, 否则返回 0</span></span><br><span class="line"><span class="comment">// 但这个接口用的比较少, 主要是用下面的那个 inet_addr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr, struct in_addr *addrptr)</span></span>;</span><br><span class="line"><span class="comment">// 和 inet_aton 功能相似, 多了一个family参数指定是IPv4还是v6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序的 32 位二进制数值转换为点分十进制的 IP 地址</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">// 和 inet_ntoa 功能相似, 多了一个family参数指定是IPv4还是v6</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>straddr</code> 存放输入的点分十进制数 IP 地址字符串</p>
<p><code>addrptr</code> <strong>传出参数</strong>，保存网络字节序的 32 位二进制数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能与 inet_aton 相同，但是结果传递的方式不同. 改函数若成功则返回 32 位二进制的网络字节序地址</span></span><br><span class="line"><span class="comment">// in_addr_t 即 结构体 in_addr 里的那个成员</span></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *straddr);</span><br></pre></td></tr></table></figure>
<h4 id="示例一：地址格式转换的简单示例"><a href="#示例一：地址格式转换的简单示例" class="headerlink" title="示例一：地址格式转换的简单示例"></a>示例一：地址格式转换的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">netIp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = inet_aton(argv[<span class="number">1</span>], &amp;netIp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这个函数返回0是失败的</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid address\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, netIp.s_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ip = %s\n"</span>, inet_ntoa(netIp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个接口用得比 inet_aton 多</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, inet_addr(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="名字地址转换"><a href="#名字地址转换" class="headerlink" title="名字地址转换"></a>名字地址转换</h3><p>通常，人们在使用过程中都不愿意记忆冗长的 IP 地址，因此，使用主机名或域名将会是很好的选择。</p>
<p><strong>主机名与域名的区别</strong>：主机名通常在局域网里面使用，通过/etc/hosts 文件，主机名可以解析到对应的 ip；域名通常是在 internet 上使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将域名或主机名转换为 IP 地址</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>name</code> 指向存放域名或主机名的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将 IP 地址转换为域名或主机名</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>addr</code> 是一个 IP 地址，此时这个ip 地址不是普通的字符串，而是要通过 <code>inet_aton()</code> 转换</p>
<p><code>len</code> 为 IP 地址的长度，AF_INET 为 4</p>
<p><code>type</code> 可用<strong>AF_INET</strong>(IPv4)或<strong>AF_INET6</strong>(IPv6)</p>
<p>这两个函数返回的结构体成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;       <span class="comment">/* 正式主机名 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;   <span class="comment">/* 主机别名 */</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;     <span class="comment">/* 主机 IP 地址类型 IPv4 为 AF_INET */</span></span><br><span class="line">    <span class="keyword">int</span> h_length;       <span class="comment">/* 主机 IP 地址字节长度，对于 IPv4 是 4 字节，即 32 位 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* 主机的 IP 地址列表, 注意这里要将网络字节序进行转换 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例一：将域名转换成IP地址"><a href="#示例一：将域名转换成IP地址" class="headerlink" title="示例一：将域名转换成IP地址"></a>示例一：将域名转换成IP地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    p = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 打印所有主机别名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; p-&gt;h_aliases[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(p-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印地址类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address type: %d\n"</span>, p-&gt;h_addrtype);</span><br><span class="line">    <span class="comment">// 打印地址长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address length: %d\n"</span>, p-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印主机的所有IP地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; p-&gt;h_addr_list[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        bzero(ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">        inet_ntop(p-&gt;h_addrtype, p-&gt;h_addr_list[i], ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">        <span class="built_in">puts</span>(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个套接口描述符, 成功返回套接口描述符, 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>domain</code> 选择类型，<strong>AF_INET</strong>是IPv4，<strong>AF_INET6</strong>是IPv6</p>
<p><code>type</code> 选择协议，<strong>SOCK_STREAM</strong>是tcp，<strong>SOCK_DGRAM</strong>是udp</p>
<p><code>protocol</code> 指定socket所使用的传输协议编号，通常为0</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来绑定一个端口号和 IP 地址，使套接口与指定的端口号和 IP 地址相关联</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 前面socket的返回值</p>
<p><code>my_addr</code> 结构体指针，现在通常使用 <code>sockaddr_in</code> 代替。</p>
<p><code>addrlen</code> 参数2指向的结构体大小</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功则返回 0, 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使<strong>服务器</strong>的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。如果客户端有连接请求，端口就会接受这个连接。可以通过指令 <code>netstat -an | grep ^tcp</code> 来查看。</p>
<p><code>sockfd</code> 前面socket的返回值</p>
<p><code>backlog</code> 指定同时能处理的最大连接数，通常为10或5</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受远程计算机的连接请求, 建立起与客户机之间的通信连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> s, struct sockaddr * addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>s</code> 为前面 socket 的返回值</p>
<p><code>addr</code> <strong>传出参数</strong>，是结构体指针变量，和 <code>bind()</code> 的结构体是同种类型的，系统会把远程主机的信息保存到这个指针所指的结构体中</p>
<p><code>addrlen</code> 表示结构体的长度，为整型指针</p>
<p>当<code>accept()</code> 接受一个连接时，<strong>会返回一个新的socket标识符</strong>， 以后的数据传输和读取就要通过这个新的 socket 编号来处理，原来参数中的 socket 也可以继续使用，继续监听其它客户机的连接请求。当 <code>accept()</code> 成功后，即完成了TCP协议的三次握手。</p>
<h4 id="示例一：accept的常用实例"><a href="#示例一：accept的常用实例" class="headerlink" title="示例一：accept的常用实例"></a>示例一：accept的常用实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;clientaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">in addrlen = <span class="keyword">sizeof</span>(sturct sockaddr);</span><br><span class="line"><span class="keyword">int</span> new_fd = accept(sfd, (struct sockaddr*)&amp;clientaddr, &amp;addrlen);</span><br></pre></td></tr></table></figure>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求连接远程服务器, 将参数 sockfd 连至参数 serv_addr 指定的服务器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr * serv_addr,<span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 为前面 <code>socket()</code> 的返回值</p>
<p><code>serv_addr</code> 为结构体指针变量，存储着远程服务器的 IP 与端口号信息</p>
<p><code>addrlen</code> 表示结构体变量的长度</p>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 使用</span></span><br><span class="line"><span class="comment">// 用新的套接字来接收远端主机传来的数据, 并把数据存到由参数 buf 指向的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 是 <code>accept()</code> 的返回值</p>
<p><code>flags</code> 通常为 0，这里列出几个常用的宏：</p>
<ul>
<li><code>MSG_PEEK</code> ：只读数据，但不从缓冲区中取出</li>
<li><code>MSG_DONTWAIT</code> ：单次非阻塞</li>
</ul>
<p>注意 <code>recv()</code> 不管有多少数据都会返回，而下面的 <code>send()</code> 如果发送的数据超出缓存，则一个都不发。</p>
<p><strong>对方断开</strong>时 <code>recv()</code>，返回 0。</p>
<p><strong>非阻塞模式下</strong>，若描述符未就绪，返回 -1。</p>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 使用</span></span><br><span class="line"><span class="comment">// 用新的套接字发送数据给指定的远端主机, 成功返回发送的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>s</code> 是 <code>accept()</code> 的返回值</p>
<p><code>flags</code> 通常为 0，这里列出几个常用的宏：</p>
<ul>
<li><code>MSG_DONTWAIT</code> 单次非阻塞  </li>
</ul>
<p><strong>对方断开</strong>或不能发送时，返回 -1，若再次执行 <code>send()</code> ，会收到 <strong>SIGPIPE</strong> 信号。</p>
<p><strong>非阻塞模式下</strong>，若描述符未就绪，返回 -1。</p>
<p>​    </p>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">             struct sockaddr *from, <span class="keyword">int</span> *fromlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数基本与TCP使用的 <code>recv()</code> 相同，额外多了两个参数：</p>
<p><code>from</code> 保存连接机的IP地址和端口号</p>
<p><code>fromlen</code> 是个传入传出参数，传入 <code>from</code> 结构体的大小，传出实际存入 <code>from</code> 中的数据字节数</p>
<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg,<span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> tolen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同样也是比 <code>send()</code> 多两个参数：</p>
<p><code>to</code> 表示目地机的 IP 地址和端口号信息</p>
<p><code>tolen</code> 表示 <code>to</code> 结构体的大小</p>
<h3 id="使用TCP协议的流程"><a href="#使用TCP协议的流程" class="headerlink" title="使用TCP协议的流程"></a>使用TCP协议的流程</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h4 id="示例一：TCP的简单使用"><a href="#示例一：TCP的简单使用" class="headerlink" title="示例一：TCP的简单使用"></a>示例一：TCP的简单使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp_server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd, newFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>, <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    ret = bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    listen(socketFd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;clientAddr, <span class="keyword">sizeof</span>(clientAddr));</span><br><span class="line">    <span class="keyword">socklen_t</span> clientLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    newFd = accept(socketFd, (struct sockaddr*)&amp;clientAddr, &amp;clientLen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip = %s, client port = %d\n"</span>, inet_ntoa(clientAddr.sin_addr),</span><br><span class="line">           ntohs(clientAddr.sin_port));</span><br><span class="line"></span><br><span class="line">    recv(newFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"server gets: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    send(newFd, <span class="string">"Hello World\n"</span>, <span class="number">13</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp_client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    ret = connect(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"connect"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line"></span><br><span class="line">    send(socketFd, <span class="string">"Nice to meet you\n"</span>, <span class="number">18</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    recv(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clinet gets: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：支持单用户断开并重连的简单聊天室"><a href="#示例二：支持单用户断开并重连的简单聊天室" class="headerlink" title="示例二：支持单用户断开并重连的简单聊天室"></a>示例二：支持单用户断开并重连的简单聊天室</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcpInit</span><span class="params">(<span class="keyword">int</span> *sfd, <span class="keyword">char</span> *ip, <span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    serAddr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    ret = bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    listen(socketFd, <span class="number">0</span>);</span><br><span class="line">    *sfd = socketFd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd, newFd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    tcpInit(&amp;socketFd, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="comment">// 所有要监控的描述符, 这是使用传入传出参数时常用的方式</span></span><br><span class="line">    fd_set foreverset;</span><br><span class="line">    FD_ZERO(&amp;foreverset);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;foreverset);</span><br><span class="line">    FD_SET(socketFd, &amp;foreverset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;rdset, &amp;foreverset, <span class="keyword">sizeof</span>(fd_set));</span><br><span class="line">        select(<span class="number">100</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">            newFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ERROR_CHECK(newFd, <span class="number">-1</span>, <span class="string">"accept"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line">            FD_SET(newFd, &amp;foreverset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// read 返回0, 表示自己主动断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(newFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(newFd, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(newFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// recv 返回0, 表示对方断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"some one close chat\n"</span>);</span><br><span class="line">                FD_CLR(newFd, &amp;foreverset);</span><br><span class="line">                close(newFd);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(newFd);</span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    ret = connect(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(socketFd, &amp;rdset);</span><br><span class="line">        select(socketFd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// read 返回0, 表示主动断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(socketFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// recv 返回0, 表示对方断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例三：多用户聊天室"><a href="#示例三：多用户聊天室" class="headerlink" title="示例三：多用户聊天室"></a>示例三：多用户聊天室</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> connectFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;User_t, *pUser_t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    fd_set rdset, allset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    pUser_t users = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line"></span><br><span class="line">    listen(socketFd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;allset);</span><br><span class="line">    FD_SET(socketFd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;rdset, &amp;allset, <span class="keyword">sizeof</span>(fd_set));</span><br><span class="line"></span><br><span class="line">        ret =select(<span class="number">100</span>,&amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有新客户端请求连接</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(socketFd,  &amp;rdset)) &#123;</span><br><span class="line">                <span class="comment">// 头插进用户链表</span></span><br><span class="line">                <span class="keyword">if</span>(users == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    users = (pUser_t)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_t));</span><br><span class="line">                    users-&gt;connectFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    users-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">                    FD_SET(users-&gt;connectFd, &amp;allset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pUser_t p = (pUser_t)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_t));</span><br><span class="line">                    p-&gt;connectFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    p-&gt;pNext = users;</span><br><span class="line">                    users = p;</span><br><span class="line">                    FD_SET(p-&gt;connectFd, &amp;allset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"chat close\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送给所有用户端</span></span><br><span class="line">                pUser_t temp = users;</span><br><span class="line">                <span class="keyword">while</span>(temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    send(temp-&gt;connectFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    temp = temp-&gt;pNext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查每一个客户端</span></span><br><span class="line">            pUser_t temp = users;</span><br><span class="line">            <span class="keyword">while</span>(temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// printf("test\n");</span></span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(temp-&gt;connectFd, &amp;rdset)) &#123;</span><br><span class="line">                    bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    ret = recv(temp-&gt;connectFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"chat close\n"</span>);</span><br><span class="line">                        FD_CLR(temp-&gt;connectFd, &amp;allset);</span><br><span class="line">                        close(temp-&gt;connectFd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 要将收到的数据发送给每个除了发送该数据的客户端</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">                        pUser_t client = users;</span><br><span class="line">                        <span class="keyword">while</span>(client != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(client-&gt;connectFd != temp-&gt;connectFd) &#123;</span><br><span class="line">                                send(client-&gt;connectFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            client = client-&gt;pNext;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp-&gt;pNext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    connect(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(socketFd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">        ret =select(socketFd+<span class="number">1</span>,&amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"chat close\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                send(socketFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = recv(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"chat close\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用UDP协议的流程"><a href="#使用UDP协议的流程" class="headerlink" title="使用UDP协议的流程"></a>使用UDP协议的流程</h3><h4 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/UDP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h4 id="示例一：UDP的简单使用"><a href="#示例一：UDP的简单使用" class="headerlink" title="示例一：UDP的简单使用"></a>示例一：UDP的简单使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>, <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 最大可以用 65535, 因为这是UDP包最大的容量</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 upd 时, bind 后端口就激活了</span></span><br><span class="line">    ret = bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> fromLen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从客户端收数据</span></span><br><span class="line">    recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;client, &amp;fromLen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip = %s, port = %d\n"</span>,</span><br><span class="line">           inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gets: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再发给客户端</span></span><br><span class="line">    sendto(socketFd, <span class="string">"Hello World!"</span>, <span class="number">13</span>, <span class="number">0</span>, (struct sockaddr*)&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="comment">// 最大可以用 65535, 因为这是UDP包最大的容量</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sendto(socketFd, <span class="string">"Nice To Meet You"</span>, <span class="number">17</span>, <span class="number">0</span>, </span><br><span class="line">           (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line"></span><br><span class="line">    recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client gets: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例二：UDP单用户简单聊天室"><a href="#示例二：UDP单用户简单聊天室" class="headerlink" title="示例二：UDP单用户简单聊天室"></a>示例二：UDP单用户简单聊天室</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>, <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 最大可以用 65535, 因为这是UDP包最大的容量</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 upd 时, bind 后端口就激活了</span></span><br><span class="line">    ret = bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> fromLen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为UDP是无连接, 因此要先被客户端连接一次, 才能知道客户端的ip等信息</span></span><br><span class="line">    recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;client, &amp;fromLen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip = %s, port = %d\n"</span>,</span><br><span class="line">           inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(socketFd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">        ret = select(socketFd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">                bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                sendto(socketFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>, </span><br><span class="line">                       (struct sockaddr*)&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">                bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 在这里可以对接收到的数据来源进行判断, 增加安全性</span></span><br><span class="line">                recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, </span><br><span class="line">                         (struct sockaddr*)&amp;client, &amp;fromLen);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="comment">// 最大可以用 65535, 因为这是UDP包最大的容量</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sendto(socketFd, <span class="string">"Nice To Meet You"</span>, <span class="number">17</span>, <span class="number">0</span>, </span><br><span class="line">           (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(socketFd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">        ret = select(socketFd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">                bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                sendto(socketFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>, </span><br><span class="line">                       (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">                bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意UDP版本和之前TCP的一个重要区别：<strong>用UDP时，若服务端的buf比客户端小，则服务端在接收客户端数据时，超出buf大小的数据会被直接丢弃掉，而采用TCP时则会分批次传送过来。</strong></p>
<h3 id="设置套接口选项"><a href="#设置套接口选项" class="headerlink" title="设置套接口选项"></a>设置套接口选项</h3><p>注意全部都必须要放在 <code>bind()</code> 之前，另外通常是用于 UDP 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 标识一个套接口的描述符</p>
<p><code>level</code> 选项定义的层次，支持 <strong>SOL_SOCKET</strong>、IPPROTO_TCP、<strong>IPPROTO_IP</strong> 和 IPPROTO_IPV6</p>
<p><code>optname</code> 需设置的选项</p>
<p><code>optval</code> 指向存放选项值的缓冲区</p>
<p><code>optlen</code> optval 缓冲区的长度</p>
<p>每个选项（ <code>level</code> ）都有很多可以设定的选项，下面只列出几个常用的，具体查看man手册</p>
<p><strong>SOL_SOCKET</strong>：</p>
<ul>
<li><code>SO_RCVBUF</code>：接收缓冲区大小</li>
<li><code>SO_SNDBUF</code>：发送缓冲区大小</li>
<li><code>SO_RCVLOWAT</code>：接收缓冲区下限，接收的数据到达了下限 <code>epoll_wait()</code> 才会认为其可读</li>
<li><code>SO_SNDLOWAT</code>：发送缓冲区下限，发送的数据到达了下限 <code>epoll_wait()</code> 才会认为其可写</li>
<li><code>SO_REUSEADDR</code>：允许重用本地地址和端口</li>
<li><code>SO_RCVTIMEO</code>：接收超时</li>
<li><code>SO_SNDTIMEO</code>：发送超时</li>
<li><code>SO_BROADCAST</code>：允许发送广播数据</li>
</ul>
<p><strong>IPPROTO_IP</strong>：</p>
<ul>
<li><code>IP_TTL</code>：生存时间</li>
</ul>
<h4 id="示例一：常用的套接口选项设置"><a href="#示例一：常用的套接口选项设置" class="headerlink" title="示例一：常用的套接口选项设置"></a>示例一：常用的套接口选项设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般在发送 UDP 数据报的时候, 希望该 socket 发送的数据具有广播特性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> bBroadcast = <span class="number">1</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_BROADCAST, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bBroadcast, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果在已经处于 ESTABLISHED 状态下的 socket(一般由端口号和标志符区分)</span></span><br><span class="line"><span class="comment">    调用 closesocket(一般不会立即关闭而经历 TIME_WAIT 的过程)后想继续重用该 socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 send(),recv()过程中有时由于网络状况等原因, 发收不能预期进行, 而设置收发时限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> nNetTimeout=<span class="number">1000</span>; <span class="comment">// 1 秒</span></span><br><span class="line">setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, (<span class="keyword">char</span> *)&amp;nNetTimeout, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 发送时限</span></span><br><span class="line">setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;nNetTimeout, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 接收时限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 send(),recv()的时候, 系统默认的状态发送和接收一次为 8688 字节(约为 8.5K);</span></span><br><span class="line"><span class="comment">    在实际的过程中发送数据和接收数据量比较大, 可以设置 socket 缓冲区, </span></span><br><span class="line"><span class="comment">    而避免了 send(),recv()不断的循环收发</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> nRecvBuf=<span class="number">32</span>*<span class="number">1024</span>; <span class="comment">// 设置为 32K</span></span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;nRecvBuf, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="keyword">int</span> nSendBuf=<span class="number">32</span>*<span class="number">1024</span>; <span class="comment">// 设置为 32K</span></span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;nSendBuf, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 发送缓冲区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果在发送或接收数据时, 希望不经历由系统缓冲区到 socket 缓冲区的拷贝而影响程序的性能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> nZero=<span class="number">0</span>;</span><br><span class="line">setsockopt(socket, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">char</span> *)&amp;nZero, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 发送</span></span><br><span class="line">setsockopt(socket, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">char</span> *)&amp;nZero, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset,fd_set *writeset, fd_set *exceptionset, struct timeval * timeout)</span></span></span><br></pre></td></tr></table></figure>
<p><code>maxfd</code> 最大的文件描述符（其值应该为最大的文件描述符的值 + 1）</p>
<p><code>readset</code> 内核读操作的描述符字集合</p>
<p><code>writeset</code> 内核写操作的描述符字集合。在管道已满，读端读取数据后，此时管道又可以写了就会发出<strong>写就绪</strong></p>
<p><code>exceptionset</code> 内核异常操作的描述符字集合</p>
<p><code>timeout</code> 等待描述符就绪需要多少时间。NULL 代表永远等下去，一个固定值代表等待固定时间，0 代表根本不等待，检查描述字之后立即返回</p>
<p>第3到第4个set都是<strong>传入传出参数</strong>，传入要监控的描述符集合，传出符合条件的描述符集合。该集合的相关操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">/* 将所有 fd 清零 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* 增加一个 fd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* 删除一个 fd */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* 判断一个 fd 是否有设置 */</span></span><br></pre></td></tr></table></figure>
<p>第5个参数timeout 是一个 struct timeval 类型的指针，也是一个<strong>传入传出参数</strong>，该结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">		<span class="keyword">long</span> tv_sec;        <span class="comment">//秒</span></span><br><span class="line">		<span class="keyword">long</span> tv_usec;       <span class="comment">//微秒 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-示例1：select的实现一个两个程序交流"><a href="#3-1-示例1：select的实现一个两个程序交流" class="headerlink" title="3.1 示例1：select的实现一个两个程序交流"></a>3.1 示例1：select的实现一个两个程序交流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chat1.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(argv[<span class="number">2</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am chat1 fdr = %d, fdw = %d\n"</span>, fdr, fdw);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        bzero(&amp;timeout, <span class="keyword">sizeof</span>(timeout));</span><br><span class="line">        timeout.tv_sec = <span class="number">3</span>;</span><br><span class="line">        ret = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        <span class="comment">// 判断select监听的文件描述符是否有符合的</span></span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">//从标准输入读</span></span><br><span class="line">                ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"break up\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//往管道里写, 发送给对端</span></span><br><span class="line">                write(fdw, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset)) &#123;</span><br><span class="line">                <span class="comment">//读管道</span></span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">//如果读到0，表示写端断开了</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//显示数据</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"time out \n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chat2.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am chat2 fdr = %d\n"</span>, fdw);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        ret = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">//从标准输入读</span></span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"break up\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往管道里写, 发送给对端</span></span><br><span class="line">            write(fdw, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset)) &#123;</span><br><span class="line">            <span class="comment">//读管道</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">//显示数据</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是在 2.6 内核中提出的，是之前的 <code>select()</code> 和 <code>poll()</code> 的增强版本。相对于 <code>select()</code> 和 <code>poll()</code> 来说，epoll更加灵活，没有描述符限制。<code>epoll()</code> <strong>使用一个文件描述符管理多个描述符</strong>，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。同时 epoll 的性能更好，因此在工作中首选 epoll。</p>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并返回一个 epoll 句柄</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>size</code> 告诉内核这个监听的数目一共有多大</p>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件注册函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>epfd</code> 是 <code>epoll_create()</code> 返回的 epoll 句柄</p>
<p><code>op</code> 表示动作，由三个可选的宏：<strong>EPOLL_CTL_ADD</strong> (注册新的fd到epfd中)、<strong>EPOLL_CTL_MOD</strong> (修改已注册的监听事件)、<strong>EPOLL_CTL_DEL</strong> (从epfd中删除一个fd)</p>
<p><code>fd</code> 需要监听的fd</p>
<p><code>event</code> 是一个结构体指针，表示需要监听什么事件，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__unit32_t</span> events;</span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;   <span class="comment">// 是个联合体, 定义如下</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;  <span class="comment">// epoll_wait 传出的也是这个结构体, 所以为了使用方便, 这里也有fd</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>events</code> 可以是以下几个宏的集合：</p>
<p><code>EOLLIN</code>：表示对应的文件描述符可以读</p>
<p><code>EPOLLOUT</code>：表示对应的文件描述符可以写</p>
<p><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</p>
<p><code>EPOLLERR</code>：表示对应的文件描述符发生错误</p>
<p><code>EPOLLHUP</code>：表示对应的文件描述符被挂断</p>
<p><code>EPOLLONESHOT</code>：只监听一次事件</p>
<p><code>EPOLLET</code>：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说 的。</p>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待事件的产生, 类似于 select()调用. 返回需要处理的事件数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>epfd</code> 是epoll句柄</p>
<p><code>events</code> <strong>传出参数</strong>，表示从内核得到事件的集合</p>
<p><code>maxevents</code> 告诉内核这个第二个参数 <code>events</code> 有多大，所以该值不能大于创建时的 <code>size</code></p>
<p> <code>timeout</code> 是超时时间，单位毫秒，0 会立即返回，-1 永久阻塞</p>
<h3 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h3><p><strong>水平触发</strong>：epoll监听的描述符中，有数据在缓冲区就会被触发。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</p>
<p><strong>边缘触发</strong>：epoll监听的描述符中，有新数据到达才会被触发。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符，<strong>降低了epoll的触发次数</strong>。</p>
<h3 id="epoll非阻塞模型"><a href="#epoll非阻塞模型" class="headerlink" title="epoll非阻塞模型"></a>epoll非阻塞模型</h3><p>首先，我们需要注意的是 <code>send()</code> 和 <code>recv()</code> 在阻塞与非阻塞情况下的不同行为。</p>
<p><code>send()</code> ：</p>
<ul>
<li>阻塞时：当发送数据大于缓冲区大小时，函数会被阻塞</li>
<li>非阻塞时：当发送数据大于缓冲区大小时，会先发送可以发送的数据大小，接着因为不能发送，返回 -1</li>
</ul>
<p><code>recv()</code> ：</p>
<ul>
<li>阻塞时：当缓冲区没有数据时，函数会被阻塞</li>
<li>非阻塞时：当缓冲区没有数据时，返回 -1</li>
</ul>
<h3 id="示例一：epoll实现单用户聊天"><a href="#示例一：epoll实现单用户聊天" class="headerlink" title="示例一：epoll实现单用户聊天"></a>示例一：epoll实现单用户聊天</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c, 客户端见 网络编程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd, newFd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> readyFdCount;</span><br><span class="line"></span><br><span class="line">    tcpInit(&amp;socketFd, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    event.events = EPOLLIN; <span class="comment">// 监听读事件</span></span><br><span class="line">    event.data.fd = STDIN_FILENO;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);</span><br><span class="line">    event.data.fd = socketFd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, socketFd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        readyFdCount = epoll_wait(epfd, evs, <span class="number">3</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readyFdCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socketFd) &#123;</span><br><span class="line">                newFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ERROR_CHECK(newFd, <span class="number">-1</span>, <span class="string">"accept"</span>);</span><br><span class="line">                event.data.fd = newFd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, newFd, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == STDIN_FILENO &amp;&amp; evs[i].events==EPOLLIN) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// read 返回0, 表示自己主动断开</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                send(newFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == newFd) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = recv(newFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// recv 返回0, 表示对方断开</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                    event.data.fd = newFd;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, newFd, &amp;event);  <span class="comment">// 解除注册</span></span><br><span class="line">                    close(newFd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例二：非阻塞边沿触发的聊天室"><a href="#示例二：非阻塞边沿触发的聊天室" class="headerlink" title="示例二：非阻塞边沿触发的聊天室"></a>示例二：非阻塞边沿触发的聊天室</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNonBlock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    status = fcntl(fd, F_GETFL);</span><br><span class="line">    status = status | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, status);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socketFd, newFd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> readyFdCount;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(socketFd, SOL_SOCKET, SO_REUSEADDR, </span><br><span class="line">               (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ret = bind(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    listen(socketFd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    event.events = EPOLLIN; <span class="comment">// 监听读事件</span></span><br><span class="line">    event.data.fd = STDIN_FILENO;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);</span><br><span class="line">    event.data.fd = socketFd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, socketFd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        readyFdCount = epoll_wait(epfd, evs, <span class="number">3</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readyFdCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socketFd) &#123;</span><br><span class="line">                newFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ERROR_CHECK(newFd, <span class="number">-1</span>, <span class="string">"accept"</span>);</span><br><span class="line">                event.data.fd = newFd;</span><br><span class="line">                event.events = EPOLLET | EPOLLIN;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, newFd, &amp;event);</span><br><span class="line">                setNonBlock(newFd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == STDIN_FILENO &amp;&amp; evs[i].events == EPOLLIN) &#123;</span><br><span class="line">                bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// read 返回0, 表示自己主动断开</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                send(newFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == newFd) &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                    bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    ret = recv(newFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// recv 返回0, 表示对方断开</span></span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                        event.data.fd = newFd;</span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL, newFd, &amp;event);  <span class="comment">// 解除注册</span></span><br><span class="line">                        <span class="keyword">goto</span> end;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// recv 返回-1, 表示读完了数据</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">end:</span><br><span class="line">    close(newFd);</span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    ret = connect(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect success\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(socketFd, &amp;rdset);</span><br><span class="line">        select(socketFd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// read 返回0, 表示主动断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(socketFd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(socketFd, &amp;rdset)) &#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// recv 返回0, 表示对方断开</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close chat\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socketFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select和epoll的比较"><a href="#select和epoll的比较" class="headerlink" title="select和epoll的比较"></a>select和epoll的比较</h2><h3 id="select的缺陷"><a href="#select的缺陷" class="headerlink" title="select的缺陷"></a>select的缺陷</h3><ol>
<li>每次调用 <code>select()</code>，都需要把fd_set集合从用户态拷贝到内核态，并且<strong>每次</strong>要把当前进程挂在描述符的等待队列上，开销大。</li>
<li><code>select()</code> 需要遍历所有描述符(轮询)，O(n)</li>
<li><code>select()</code> 支持的文件描述符数量太小了，默认 1024</li>
</ol>
<h3 id="epoll的改进"><a href="#epoll的改进" class="headerlink" title="epoll的改进"></a>epoll的改进</h3><ol>
<li>在 <code>epoll_ctl()</code> 函数中注册新的描述符到epfd时， 把需要监听的fd添加到红黑树上，不需要重复拷贝，并且把当前进程挂到等待队列上，并设置回调函数。</li>
<li>描述符就绪时，唤醒等待队列上的进程，执行回调函数，把就绪的描述符放入就绪链表，<code>epoll_wait()</code> 每次只检查就绪链表是否为空，不需要轮询 O(1)。</li>
<li>epoll采用树和链表保存描述符，上限是最大可以打开的文件的数目，跟系统内存有关。</li>
</ol>
<hr>
<p><br></p>
<p><br></p>
<h1 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h1><h2 id="进程间传递文件描述符"><a href="#进程间传递文件描述符" class="headerlink" title="进程间传递文件描述符"></a>进程间传递文件描述符</h2><p>当一个进程创建一个子进程后，要把自己的文件描述符传送给子进程。此时，如果仅仅使用普通的管道，只会把文件描述符的数值传给子进程，并不能从内核层面上进行描述符的传递这个文件描述符过去。因此就需要一套新的方法流程，由以下3个函数组成。</p>
<h3 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair"></a>socketpair</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 socketpair 类型描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个全双工的管道，使用方法和建立管道的 <code>pipe()</code> 类似。</p>
<h3 id="sendmsg"><a href="#sendmsg" class="headerlink" title="sendmsg"></a>sendmsg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送文件描述符</span></span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 即前面 <code>socketpair()</code> 初始化的描述符</p>
<p><code>msg</code> 结构体指针，是该函数的关键，该结构体成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *msg_name;         <span class="comment">/* optional address, 没用 */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen;  <span class="comment">/* size of address, 没用 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>  <span class="comment">/* scatter/gather array, 用处不大 */</span></span><br><span class="line">    <span class="keyword">size_t</span> msg_iovlen;      <span class="comment">/* elements in msg_iov, 用处不大 */</span> </span><br><span class="line">    <span class="keyword">void</span> *msg_control;      <span class="comment">/* 关键, 即下面的 cmsghdr 结构体地址 */</span></span><br><span class="line">    <span class="keyword">size_t</span> msg_controllen;  <span class="comment">/* cmsghdr 结构体的长度 */</span> </span><br><span class="line">    <span class="keyword">int</span> msg_flags;          <span class="comment">/* flags (unused), 没用 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cmsg_len;    <span class="comment">/* data byte count, including header */</span></span><br><span class="line">    <span class="keyword">int</span> cmsg_level;        <span class="comment">/* originating protocol */</span></span><br><span class="line">    <span class="keyword">int</span> cmsg_type;         <span class="comment">/* protocol-specific type */</span></span><br><span class="line">    <span class="keyword">char</span> cmsg_data[];      <span class="comment">/* 要传递的文件描述符, 通过CMSG_DATA来获得最后位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="recvmsg"><a href="#recvmsg" class="headerlink" title="recvmsg"></a>recvmsg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收文件描述符</span></span><br><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>接收的 msghdr 结构体初始化和 <code>sendmsg()</code> 几乎完全一致，区别在于是 <code>*fd = *fdptr;</code></p>
<h3 id="示例一：把文件描述符传递给子进程"><a href="#示例一：把文件描述符传递给子进程" class="headerlink" title="示例一：把文件描述符传递给子进程"></a>示例一：把文件描述符传递给子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>] = <span class="string">"world"</span>;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>; <span class="comment">// 2个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cmsgLen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 一个文件描述符</span></span><br><span class="line">    cmsg = (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, cmsgLen);</span><br><span class="line">    cmsg-&gt;cmsg_len = cmsgLen;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="keyword">int</span> *)CMSG_DATA(cmsg) = fd;   <span class="comment">// 要把传递的描述符告诉内核</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = cmsgLen;</span><br><span class="line"></span><br><span class="line">    ret = sendmsg(pipeFd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sendmsg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>];</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>; <span class="comment">// 2个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cmsgLen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 一个文件描述符</span></span><br><span class="line">    cmsg = (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, cmsgLen);</span><br><span class="line">    cmsg-&gt;cmsg_len = cmsgLen;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">  </span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = cmsgLen;</span><br><span class="line"></span><br><span class="line">    ret = recvmsg(pipeFd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"recvmsg"</span>);</span><br><span class="line"></span><br><span class="line">    *fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"socketpair"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        recvFd(fds[<span class="number">0</span>], &amp;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, get fd = %d\n"</span>, fd);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, buf = %s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent, send fd = %d\n"</span>, fd);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sendFd(fds[<span class="number">1</span>], fd);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程池代码编写流程"><a href="#进程池代码编写流程" class="headerlink" title="进程池代码编写流程"></a>进程池代码编写流程</h2><p><strong>第一步</strong>：<code>make_child()</code> 函数初始化子进程。循环创建子进程，并初始化父进程的子进程管理结构体数组 parr，通过 <code>socket_pair()</code> 将 socket 描述符一端放入数组</p>
<p><strong>第二步</strong>：子进程流程，目前让子进程死循环，接收任务，给客户端发文件，然后通知父进程完成任务，退出机制暂时先不考虑 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Recv_fd 等待父进程发送任务 </span><br><span class="line">    Hand_request 发送文件数据 </span><br><span class="line">    Write 向父进程发送完成任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三步：</strong>父进程 epoll 监控 fd_listen 描述符。父进程 epoll 监控 parr 结构体数组的 socket 描述符，结构体数组中的描述符是每一个子进程的管道对端，通过监控这个，当子进程通过 write 向我们写通知时，我们就知道子进程非忙碌了。</p>
<p><strong>第四步：</strong>While 1 启动 <code>epoll_wait()</code>，等待是否有客户端连接。有客户端连接后，<code>accept()</code> 获得描述符，循环找到非忙碌的子进程，并发送给子进程，标记对应子进程忙碌。当子进程完成任务后，父进程一旦监控 socket 描述符可读，代表子进程非忙碌，然后标记子进程非忙碌。</p>
<h2 id="示例一：子进程从服务器端下载数据"><a href="#示例一：子进程从服务器端下载数据" class="headerlink" title="示例一：子进程从服务器端下载数据"></a>示例一：子进程从服务器端下载数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./server ip port process_num\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> processNum;</span><br><span class="line">    <span class="keyword">process_data_t</span> *pData;</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建n个子进程, 并将其放到 pData 位置</span></span><br><span class="line">    processNum = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    pData = (<span class="keyword">process_data_t</span>*)<span class="built_in">calloc</span>(processNum, <span class="keyword">sizeof</span>(<span class="keyword">process_data_t</span>));</span><br><span class="line">    makeChild(pData, processNum);</span><br><span class="line"></span><br><span class="line">    tcpInit(&amp;socketFd, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);   <span class="comment">// 初始化socket并开始监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">evs</span>;</span></span><br><span class="line">    evs = (struct epoll_event*)<span class="built_in">calloc</span>(processNum+<span class="number">1</span>, <span class="keyword">sizeof</span>(struct epoll_event));</span><br><span class="line">    epollInAdd(epfd, socketFd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">        epollInAdd(epfd, pData[i].pipeFd);  <span class="comment">// 监听每个子进程的管道对端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readyFdCount;</span><br><span class="line">    <span class="keyword">int</span> newFd;</span><br><span class="line">    <span class="keyword">char</span> noBusyFlag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        readyFdCount = epoll_wait(epfd, evs, processNum+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readyFdCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socketFd) &#123;</span><br><span class="line">                newFd = accept(socketFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">// 接收客户端请求</span></span><br><span class="line">                <span class="comment">// 寻找空闲的子进程</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; processNum; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pData[j].busy == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 把任务发给对应子进程</span></span><br><span class="line">                        sendFd(pData[j].pipeFd, newFd);</span><br><span class="line">                        <span class="comment">// 注意将newFd发送过去后, 主进程应关闭该描述符</span></span><br><span class="line">                        pData[j].busy = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d pid is busy\n"</span>, pData[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有空闲子进程时断开连接, 让客户再次请求</span></span><br><span class="line">                close(newFd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; processNum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd == pData[j].pipeFd) &#123;</span><br><span class="line">                    <span class="comment">// 读出来的数据无用, 但不读出就会一直阻塞</span></span><br><span class="line">                    read(pData[j].pipeFd, &amp;noBusyFlag, <span class="number">1</span>);</span><br><span class="line">                    pData[j].busy = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d pid is not busy\n"</span>, pData[j].pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    ret = connect(socketFd, (struct sockaddr*)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> dataLen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先接一个文件名</span></span><br><span class="line">    recvCycle(socketFd, &amp;dataLen, <span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd, buf, dataLen);</span><br><span class="line">    fd = open(buf, O_CREAT|O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收文件大小</span></span><br><span class="line">    <span class="comment">// lastLoadSize 最后一次下载, slice</span></span><br><span class="line">    <span class="keyword">off_t</span> fileSize, downLoadSize = <span class="number">0</span>, lastLoadSize = <span class="number">0</span>, slice;</span><br><span class="line">    recvCycle(socketFd, &amp;dataLen, <span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd, &amp;fileSize, dataLen);</span><br><span class="line">    slice = fileSize / <span class="number">10000</span>;   <span class="comment">// 避免频繁使用除法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环接收文件内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        recvCycle(socketFd, &amp;dataLen, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(dataLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意此处如果使用普通的recv, 可能会导致缓冲区还未准备好足够数据</span></span><br><span class="line">            <span class="comment">// recv(socketFd, buf, dataLen, 0);</span></span><br><span class="line">            recvCycle(socketFd, buf, dataLen);</span><br><span class="line">            write(fd, buf, dataLen);</span><br><span class="line">            downLoadSize += dataLen;</span><br><span class="line">            <span class="keyword">if</span>(downLoadSize - lastLoadSize &gt;= slice) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%5.2f%s\r"</span>, (<span class="keyword">float</span>)downLoadSize/fileSize*<span class="number">100</span>, <span class="string">"%"</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                lastLoadSize = downLoadSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"100.00%%\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    close(socketFd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c 与 client.c 中几个用到的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeChild</span><span class="params">(<span class="keyword">process_data_t</span> *p, <span class="keyword">int</span> processNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">        ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"socketpair"</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            childHandle(fds[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            p[i].pid = pid;</span><br><span class="line">            p[i].pipeFd = fds[<span class="number">0</span>];   <span class="comment">// 存储每个子进程的管道对端</span></span><br><span class="line">            p[i].busy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">childHandle</span><span class="params">(<span class="keyword">int</span> pipeFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newFd;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        recvFd(pipeFd, &amp;newFd); <span class="comment">// 接收任务, 无任务时会阻塞</span></span><br><span class="line">        transFile(newFd);  <span class="comment">// 给客户端发文件</span></span><br><span class="line">        write(pipeFd, &amp;newFd, <span class="number">1</span>);   <span class="comment">// 子进程完成任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epollInAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>] = <span class="string">"world"</span>;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>; <span class="comment">// 2个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cmsgLen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 一个文件描述符</span></span><br><span class="line">    cmsg = (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, cmsgLen);</span><br><span class="line">    cmsg-&gt;cmsg_len = cmsgLen;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="keyword">int</span> *)CMSG_DATA(cmsg) = fd;   <span class="comment">// 要把传递的描述符告诉内核</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = cmsgLen;</span><br><span class="line"></span><br><span class="line">    ret = sendmsg(pipeFd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"sendmsg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    bzero(&amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>];</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">2</span>; <span class="comment">// 2个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cmsgLen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 一个文件描述符</span></span><br><span class="line">    cmsg = (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, cmsgLen);</span><br><span class="line">    cmsg-&gt;cmsg_len = cmsgLen;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = cmsgLen;</span><br><span class="line"></span><br><span class="line">    ret = recvmsg(pipeFd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"recvmsg"</span>);</span><br><span class="line"></span><br><span class="line">    *fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transFile</span><span class="params">(<span class="keyword">int</span> newFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    train.dataLen = <span class="built_in">strlen</span>(FILENAME);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.buf, FILENAME);</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(FILENAME, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((train.dataLen = read(fd, train.buf, <span class="keyword">sizeof</span>(train.buf)))) &#123;</span><br><span class="line">        ret = send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送结束数据</span></span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvCycle</span><span class="params">(<span class="keyword">int</span> sfd, <span class="keyword">void</span>* buf, <span class="keyword">int</span> recvLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(total &lt; recvLen) &#123;</span><br><span class="line">        ret = recv(sfd, p+total, recvLen-total, <span class="number">0</span>);</span><br><span class="line">        total += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例二：使用mmap方式提高效率"><a href="#示例二：使用mmap方式提高效率" class="headerlink" title="示例二：使用mmap方式提高效率"></a>示例二：使用mmap方式提高效率</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transFile</span><span class="params">(<span class="keyword">int</span> newFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送文件名</span></span><br><span class="line">    train.dataLen = <span class="built_in">strlen</span>(FILENAME);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.buf, FILENAME);</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小给客户端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILENAME, O_RDWR);</span><br><span class="line">    fstat(fd,&amp;buf);</span><br><span class="line">    train.dataLen=<span class="keyword">sizeof</span>(buf.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.buf, &amp;buf.st_size, train.dataLen);</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件内容</span></span><br><span class="line">    <span class="keyword">char</span> *pMap = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, buf.st_size, PROT_READ|PROT_WRITE,</span><br><span class="line">                             MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(pMap, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">"mmap"</span>);</span><br><span class="line">    ret=send(newFd, pMap,buf.st_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> dataLen;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    bzero(&amp;serAddr,<span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family=AF_INET;</span><br><span class="line">    serAddr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    ret=connect(socketFd,(struct sockaddr*)&amp;serAddr,<span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收文件名</span></span><br><span class="line">    recvCycle(socketFd,&amp;dataLen,<span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd,buf,dataLen);</span><br><span class="line">    fd=open(buf,O_CREAT|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd,<span class="number">-1</span>,<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收文件大小</span></span><br><span class="line">    <span class="keyword">off_t</span> fileSize;</span><br><span class="line">    recvCycle(socketFd,&amp;dataLen,<span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd,&amp;fileSize,dataLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收文件内容</span></span><br><span class="line">    gettimeofday(&amp;start,<span class="literal">NULL</span>);</span><br><span class="line">    ftruncate(fd,fileSize);</span><br><span class="line">    <span class="keyword">char</span> *pMap=(<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>,fileSize,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(pMap,(<span class="keyword">char</span>*)<span class="number">-1</span>,<span class="string">"mmap"</span>);</span><br><span class="line">    recvCycle(socketFd,pMap,fileSize);</span><br><span class="line">    munmap(pMap,fileSize);</span><br><span class="line">    gettimeofday(&amp;end,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use time=%ld.%d\n"</span>,end.tv_sec-start.tv_sec,</span><br><span class="line">           <span class="built_in">abs</span>(<span class="keyword">int</span>(end.tv_usec-start.tv_usec))/<span class="number">1000</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    close(socketFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例三：使用sendfile-和splice-实现零拷贝"><a href="#示例三：使用sendfile-和splice-实现零拷贝" class="headerlink" title="示例三：使用sendfile()和splice()实现零拷贝"></a>示例三：使用sendfile()和splice()实现零拷贝</h2><p>当我们内存空间不足时，使用 <code>mmap()</code> 的效率就不太好，此时我们可以使用 <code>sendfile()</code> 实现<strong>零拷贝</strong>来提高效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// out_fd 写到哪, in_fd 从哪读. 注意 in_fd 必须是文件</span></span><br><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd_in 是socket, 但 fd_out 不能直接是文件, 往往需要使用管道进行两次 splice()</span></span><br><span class="line"><span class="comment">// 若 fd_in 断开, 则返回 0</span></span><br><span class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out,</span><br><span class="line">                      <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transFile</span><span class="params">(<span class="keyword">int</span> newFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送文件名</span></span><br><span class="line">    train.dataLen = <span class="built_in">strlen</span>(FILENAME);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.buf, FILENAME);</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小给客户端</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILENAME, O_RDWR);</span><br><span class="line">    fstat(fd, &amp;buf);</span><br><span class="line">    train.dataLen = <span class="keyword">sizeof</span>(buf.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.buf, &amp;buf.st_size, train.dataLen);</span><br><span class="line">    send(newFd, &amp;train, <span class="number">4</span>+train.dataLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送文件内容</span></span><br><span class="line">    ret = sendfile(newFd, fd, <span class="literal">NULL</span>, buf.st_size);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束标志</span></span><br><span class="line">    send(newFd,&amp;train,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> dataLen;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serAddr</span>;</span></span><br><span class="line">    bzero(&amp;serAddr,<span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_family=AF_INET;</span><br><span class="line">    serAddr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serAddr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    ret=connect(socketFd,(struct sockaddr*)&amp;serAddr,<span class="keyword">sizeof</span>(serAddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收文件名</span></span><br><span class="line">    recvCycle(socketFd,&amp;dataLen,<span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd,buf,dataLen);</span><br><span class="line">    fd=open(buf,O_CREAT|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd,<span class="number">-1</span>,<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收文件大小</span></span><br><span class="line">    <span class="keyword">off_t</span> fileSize, downLoadSize = <span class="number">0</span>;</span><br><span class="line">    recvCycle(socketFd,&amp;dataLen,<span class="number">4</span>);</span><br><span class="line">    recvCycle(socketFd,&amp;fileSize,dataLen);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 接收文件内容</span></span><br><span class="line">    pipe(fds);</span><br><span class="line">    <span class="keyword">while</span>(downLoadSize &lt; fileSize) &#123;</span><br><span class="line">        ret = splice(socketFd, <span class="literal">NULL</span>, fds[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32767</span>,</span><br><span class="line">                     SPLICE_F_MOVE|SPLICE_F_MORE);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"splice"</span>);</span><br><span class="line">        splice(fds[<span class="number">0</span>], <span class="literal">NULL</span>, fd, <span class="literal">NULL</span>, ret, SPLICE_F_MOVE|SPLICE_F_MORE);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"splice"</span>);</span><br><span class="line">        downLoadSize += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"use time=%ld.%d\n"</span>,end.tv_sec-start.tv_sec,</span><br><span class="line">           <span class="built_in">abs</span>(end.tv_usec-start.tv_usec));</span><br><span class="line">    close(fd);</span><br><span class="line">    close(socketFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<p><br></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="格林威治时间"><a href="#格林威治时间" class="headerlink" title="格林威治时间"></a>格林威治时间</h2><h3 id="示例一：gmtime的简单示例"><a href="#示例一：gmtime的简单示例" class="headerlink" title="示例一：gmtime的简单示例"></a>示例一：gmtime的简单示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将距离1970年的秒数存入now</span></span><br><span class="line">    time(&amp;now);</span><br><span class="line">    p = gmtime(&amp;now);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%04d-%02d-%02d  %02d:%02d:%02d  %d %d\n"</span>, p-&gt;tm_year+<span class="number">1900</span>, p-&gt;tm_mon+<span class="number">1</span>, p-&gt;tm_mday,</span><br><span class="line">           p-&gt;tm_hour+<span class="number">8</span>, p-&gt;tm_min, p-&gt;tm_sec, p-&gt;tm_wday+<span class="number">1</span>, p-&gt;tm_yday);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>tm</code> 结构体的内容为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec;    <span class="comment">/* Seconds (0-60) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;    <span class="comment">/* Minutes (0-59) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour;   <span class="comment">/* Hours (0-23) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday;   <span class="comment">/* Day of the month (1-31) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;    <span class="comment">/* Month (0-11) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;   <span class="comment">/* Year - 1900 */</span></span><br><span class="line">    <span class="keyword">int</span> tm_wday;   <span class="comment">/* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_yday;   <span class="comment">/* Day in the year (0-365, 1 Jan = 0) */</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst;  <span class="comment">/* Daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday"></a>gettimeofday</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>tv</code> 是一个 <code>timeval</code> 结构体指针，作传出参数，这个结构体的成员为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span>       tv_sec;    <span class="comment">// 秒</span></span><br><span class="line">    <span class="keyword">suseconds_t</span>  tv_usec;   <span class="comment">// 微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>tz</code> 是时区，一般用NULL取默认的就好</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="大页"><a href="#大页" class="headerlink" title="大页"></a>大页</h3><p>都知道每个进程都有其各自的虚拟地址，但操作系统是如何将虚拟地址转换为真实的物理地址的呢？为了方便描述以32位操作系统为例，此时常规的4KB分页，32位的虚拟地址会被分成3个域：</p>
<p><img src="https://hexo-bucket.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80.png" alt=""></p>
<p>由图易得，虚拟地址转物理地址是通过<strong>页目录</strong>索引<strong>页表</strong>最后索引到<strong>页</strong>得到的。页的地址有12位，所以4KB的页就是这么来的。</p>
<p>如果每次转换都要一步步按照这样的规则来，无疑会降低程序的效率。因此又引入 <strong>快表(TLB)</strong> 的概念，即将经常用到的地址转换关系，保存在一块快速的缓冲区中，在寻址之前先去快表中寻找是否之前已经存有转换后的物理地址，若有，则可以省去转换的步骤。</p>
<p>后来，为了减小块表MISS的概率，又想出了 <strong>大页</strong> 的机制，即<strong>把页的大小设置为大于4KB，这样的话在块表中就更容易命中目标地址</strong>。大页主要用在两个地方：共享内存时</p>
<p>在Linux下要使用大页的话，需要使用 <code>echo 20 &gt; /proc/sys/vm/nr_hugepages</code> 打开大页开关，否则只能按照默认的4Kb分页。打开后可以使用 <code>cat /proc/meminfo</code> 来查看内存的使用情况是否是大页。</p>
<p>大页的使用主要是<strong>在需要分配较大空间的共享内存与用 <code>mmap()</code> 实现共享内存的时候</strong>。</p>
<h4 id="共享内存使用大页"><a href="#共享内存使用大页" class="headerlink" title="共享内存使用大页"></a>共享内存使用大页</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_HUGE_2MB (1 &lt;&lt; 21)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    shmid = shmget(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">21</span>, IPC_CREAT|<span class="number">0600</span>|SHM_HUGETLB|SHM_HUGE_2MB);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">"shmget"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mmap使用大页"><a href="#mmap使用大页" class="headerlink" title="mmap使用大页"></a>mmap使用大页</h4><p>首先在 <code>/mnt/huge/</code> 目录下创建文件，注意这里要使用 <code>mount none /mnt/huge -t hugetlbfs</code> 将这个目录设置为大页的文件系统，此后，只要是在 <code>/mnt/huge/</code> 目录下创建的文件，将其映射到内存中时都会使用 2MB 作为分页的基本单位。使用 <code>umount /mnt/huge/</code> 可以取消挂载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">"open"</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">10</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, mmap is : %s\n"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p, <span class="string">"Hello"</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时钟处理"><a href="#时钟处理" class="headerlink" title="时钟处理"></a>时钟处理</h2><p>Linux 为每个进程维护 3 个计时器，分别是<strong>真实计时器</strong>、<strong>虚拟计时器</strong>和<strong>实用计时器</strong>。</p>
<ul>
<li>真实计时器：计算的是程序运行的实际时间</li>
<li>虚拟计时器：计算的是程序运行在用户态时所消耗的时间，可以认为是实际时间减去系统调用和程序睡眠所消耗的时间</li>
<li>实用计时器： 计算的是程序处于用户态和处于内核态所消耗的时间之和，简而言之，就是消耗的时间片之和，这个是<strong>最常用</strong>的。</li>
</ul>
<p>例如：有一程序运行，在用户态运行了 5 秒，在内核态运行了 6 秒，还睡眠了 7 秒，则真实计算器计算的结果是 18 秒，虚拟计时器计算的是 5 秒，实用计时器计算的是 11 秒。</p>
<p>几个重要的函数：</p>
<h3 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置计时器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *value, struct itimerval *ovalue)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>which</code>  指定哪个计时器，可选项为 <strong>ITIMER_REAL</strong>(真实计时器)、<strong>ITIMER_VIRTUAL</strong>(虚拟计时器、<strong>ITIMER_PROF</strong>(实用计时器。注意这三个时钟的信号分别为：<strong>SIGALRM</strong>、<strong>SIGVTALRM</strong> 和 <strong>SIGPROF</strong>。</p>
<p><code>value</code> 是一个结构体作<strong>传入参数</strong>，用于记录该计时器的初始间隔时间和重复间隔时间</p>
<p><code>ovalue</code> 是一个结构体作<strong>传出参数</strong>，用于记录以前的计时器时间设置</p>
<p>关于这个结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>    <span class="comment">// 重复间隔</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>       <span class="comment">// 初始间隔</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;    <span class="comment">// 时间的秒数部分</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;   <span class="comment">// 时间的微秒部分</span></span><br></pre></td></tr></table></figure>
<h4 id="示例一：setitimer的简单示例"><a href="#示例一：setitimer的简单示例" class="headerlink" title="示例一：setitimer的简单示例"></a>示例一：setitimer的简单示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    time(&amp;now); <span class="comment">// 获取当前距1970s的秒数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ctime(&amp;now));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, sigFunc);</span><br><span class="line">    bzero(&amp;t, <span class="keyword">sizeof</span>(t));</span><br><span class="line">    t.it_value.tv_sec = <span class="number">2</span>;     <span class="comment">// 2秒后开始</span></span><br><span class="line">    t.it_interval.tv_sec = <span class="number">3</span>;  <span class="comment">// 开始后每3秒一次</span></span><br><span class="line"></span><br><span class="line">    sigFunc(<span class="number">0</span>);</span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;t, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"setitimer"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="描述符属性修改"><a href="#描述符属性修改" class="headerlink" title="描述符属性修改"></a>描述符属性修改</h2><p>总所周知，当我们使用 <code>read()</code> 从标准输入中读取数据时，若此时缓冲区内没有数据，该函数就会被暂时阻塞等待输入。但当我们修改标准输入的文件描述符属性时，他就不会阻塞等待了。我们使用 <code>fcntl()</code> 来实现这个效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code> 代表将要设置的文件描述符</p>
<p><code>cmd</code> 代表打算操作的指令</p>
<p><code>arg</code> 根据第二个参数 <code>cmd</code> 的不同有不同的意义</p>
<h3 id="示例一：将标准输入设置为非阻塞"><a href="#示例一：将标准输入设置为非阻塞" class="headerlink" title="示例一：将标准输入设置为非阻塞"></a>示例一：将标准输入设置为非阻塞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNonBlock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    status = fcntl(fd, F_GETFL);</span><br><span class="line">    status = status|O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    setNonBlock(<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret = %d, buf = %s\n"</span>, ret, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/27/Linux常用指令/" rel="next" title="Linux常用指令">
                <i class="fa fa-chevron-left"></i> Linux常用指令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="0ran9e">
            
              <p class="site-author-name" itemprop="name">0ran9e</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="mailto:971109888@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/3190492602" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i>微博</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#文件操作"><span class="nav-number">1.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#打开、关闭文件"><span class="nav-number">1.1.</span> <span class="nav-text">打开、关闭文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open、close"><span class="nav-number">1.1.1.</span> <span class="nav-text">open、close</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：使用open打开一个文件"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">示例一：使用open打开一个文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fopen、fclose"><span class="nav-number">1.1.2.</span> <span class="nav-text">fopen、fclose</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：文件指针转换文件描述符"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">示例一：文件指针转换文件描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：文件描述符转换文件指针"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">示例二：文件描述符转换文件指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读、写文件"><span class="nav-number">1.2.</span> <span class="nav-text">读、写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#read、write"><span class="nav-number">1.2.1.</span> <span class="nav-text">read、write</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：read的简单示例"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">示例一：read的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：write的简单示例"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">示例二：write的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fread、fwrite"><span class="nav-number">1.2.2.</span> <span class="nav-text">fread、fwrite</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改变文件大小"><span class="nav-number">1.3.</span> <span class="nav-text">改变文件大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate"><span class="nav-number">1.3.1.</span> <span class="nav-text">truncate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftruncate"><span class="nav-number">1.3.2.</span> <span class="nav-text">ftruncate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件定位"><span class="nav-number">1.4.</span> <span class="nav-text">文件定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lseek"><span class="nav-number">1.4.1.</span> <span class="nav-text">lseek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fseek"><span class="nav-number">1.4.2.</span> <span class="nav-text">fseek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：lseek的简单示例"><span class="nav-number">1.4.3.</span> <span class="nav-text">示例一：lseek的简单示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：lseek实现文件空洞"><span class="nav-number">1.4.4.</span> <span class="nav-text">示例二：lseek实现文件空洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取文件信息"><span class="nav-number">1.5.</span> <span class="nav-text">获取文件信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stat"><span class="nav-number">1.5.1.</span> <span class="nav-text">stat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fstat"><span class="nav-number">1.5.2.</span> <span class="nav-text">fstat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：打印文件的文件状态"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">示例一：打印文件的文件状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存映射"><span class="nav-number">1.6.</span> <span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap、munmap"><span class="nav-number">1.6.1.</span> <span class="nav-text">mmap、munmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：mmap简单示例"><span class="nav-number">1.6.2.</span> <span class="nav-text">示例一：mmap简单示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件描述符的复制"><span class="nav-number">1.7.</span> <span class="nav-text">文件描述符的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dup"><span class="nav-number">1.7.1.</span> <span class="nav-text">dup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup2"><span class="nav-number">1.7.2.</span> <span class="nav-text">dup2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：dup版重定向标准输出"><span class="nav-number">1.7.3.</span> <span class="nav-text">示例一：dup版重定向标准输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：dup2版重定向标准输出"><span class="nav-number">1.7.4.</span> <span class="nav-text">示例二：dup2版重定向标准输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个常用的文件操作函数"><span class="nav-number">1.8.</span> <span class="nav-text">几个常用的文件操作函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件夹操作"><span class="nav-number">2.</span> <span class="nav-text">文件夹操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件夹"><span class="nav-number">2.1.</span> <span class="nav-text">创建文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文件夹"><span class="nav-number">2.2.</span> <span class="nav-text">删除文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开文件夹"><span class="nav-number">2.3.</span> <span class="nav-text">打开文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取文件夹下的信息"><span class="nav-number">2.4.</span> <span class="nav-text">读取文件夹下的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：打印当前目录的所有文件"><span class="nav-number">2.4.1.</span> <span class="nav-text">示例一：打印当前目录的所有文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：文件夹的深度遍历"><span class="nav-number">2.4.2.</span> <span class="nav-text">示例二：文件夹的深度遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件夹定位"><span class="nav-number">2.5.</span> <span class="nav-text">文件夹定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#telldir"><span class="nav-number">2.5.1.</span> <span class="nav-text">telldir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#seekdir"><span class="nav-number">2.5.2.</span> <span class="nav-text">seekdir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rewinddir"><span class="nav-number">2.5.3.</span> <span class="nav-text">rewinddir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：打印-seekdir-c-文件的下一个文件"><span class="nav-number">2.5.4.</span> <span class="nav-text">示例一：打印 seekdir.c 文件的下一个文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个文件夹的函数"><span class="nav-number">2.6.</span> <span class="nav-text">几个文件夹的函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">3.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程概述"><span class="nav-number">3.1.</span> <span class="nav-text">进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程标识"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程标识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：获得进程的pid与ppid"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">示例一：获得进程的pid与ppid</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的运行身份"><span class="nav-number">3.1.2.</span> <span class="nav-text">进程的运行身份</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：显示进程的四种运行身份"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">示例一：显示进程的四种运行身份</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程状态与管理"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程状态与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#top"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">top</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程结构"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程创建"><span class="nav-number">3.2.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">3.2.1.</span> <span class="nav-text">fork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：fork引出的写时复制"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">示例一：fork引出的写时复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：关于缓冲区的易错点"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">示例二：关于缓冲区的易错点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec-函数族"><span class="nav-number">3.2.2.</span> <span class="nav-text">exec 函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：execl的简单示例"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">示例一：execl的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system"><span class="nav-number">3.2.3.</span> <span class="nav-text">system</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程"><span class="nav-number">3.3.1.</span> <span class="nav-text">孤儿进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：制造一个孤儿进程"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">示例一：制造一个孤儿进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#僵尸进程"><span class="nav-number">3.3.2.</span> <span class="nav-text">僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：制造一个僵尸进程"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">示例一：制造一个僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：wait-的简单示例"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">示例二：wait() 的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例三：waitpid-的简单示例"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">示例三：waitpid() 的简单示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程终止"><span class="nav-number">3.4.</span> <span class="nav-text">进程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护进程"><span class="nav-number">3.5.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">3.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤"><span class="nav-number">3.5.2.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">3.5.3.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">4.1.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准流管道"><span class="nav-number">4.1.1.</span> <span class="nav-text">标准流管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：利用popen从被调用程序读数据"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">示例一：利用popen从被调用程序读数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：利用popen向被调用程序写数据"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">示例二：利用popen向被调用程序写数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无名管道"><span class="nav-number">4.1.2.</span> <span class="nav-text">无名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：无名管道的简单示例"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">示例一：无名管道的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名管道"><span class="nav-number">4.1.3.</span> <span class="nav-text">命名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建、删除FIFO文件"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">创建、删除FIFO文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#示例一：创建与删除FIFO文件"><span class="nav-number">4.1.3.1.1.</span> <span class="nav-text">示例一：创建与删除FIFO文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打开、关闭FIFO文件"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">打开、关闭FIFO文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：命名管道的简单示例"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">示例一：命名管道的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：通过管道进行通信"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">示例二：通过管道进行通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享内存"><span class="nav-number">4.2.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ftok"><span class="nav-number">4.2.1.</span> <span class="nav-text">ftok</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：ftok的简单示例"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">示例一：ftok的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmget"><span class="nav-number">4.2.2.</span> <span class="nav-text">shmget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmat"><span class="nav-number">4.2.3.</span> <span class="nav-text">shmat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：shmget与shmat的简单组合使用"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">示例一：shmget与shmat的简单组合使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmdt"><span class="nav-number">4.2.4.</span> <span class="nav-text">shmdt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmctl"><span class="nav-number">4.2.5.</span> <span class="nav-text">shmctl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储映射"><span class="nav-number">4.3.</span> <span class="nav-text">存储映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">4.3.1.</span> <span class="nav-text">mmap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列"><span class="nav-number">4.4.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#msgget"><span class="nav-number">4.4.1.</span> <span class="nav-text">msgget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgsnd"><span class="nav-number">4.4.2.</span> <span class="nav-text">msgsnd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgrcv"><span class="nav-number">4.4.3.</span> <span class="nav-text">msgrcv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgctl"><span class="nav-number">4.4.4.</span> <span class="nav-text">msgctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：一个简单的消息发送与接受"><span class="nav-number">4.4.5.</span> <span class="nav-text">示例一：一个简单的消息发送与接受</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号"><span class="nav-number">4.5.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal"><span class="nav-number">4.5.2.</span> <span class="nav-text">signal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：signal-的简单示例"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">示例一：signal 的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：关于signal机制的一个问题"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">示例二：关于signal机制的一个问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaction"><span class="nav-number">4.5.3.</span> <span class="nav-text">sigaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：sigaction的简单示例"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">示例一：sigaction的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：sigaction与signal的不同"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">示例二：sigaction与signal的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例三：信号集的几个函数示例"><span class="nav-number">4.5.3.3.</span> <span class="nav-text">示例三：信号集的几个函数示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例四：打印发送信号者的信息"><span class="nav-number">4.5.3.4.</span> <span class="nav-text">示例四：打印发送信号者的信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigprocmask"><span class="nav-number">4.5.4.</span> <span class="nav-text">sigprocmask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：使用sigprocmask设置阻塞信号集"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">示例一：使用sigprocmask设置阻塞信号集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-number">4.5.5.</span> <span class="nav-text">kill</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：用kill实现类似kill指令"><span class="nav-number">4.5.5.1.</span> <span class="nav-text">示例一：用kill实现类似kill指令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程同步"><span class="nav-number">5.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量"><span class="nav-number">5.1.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#semget"><span class="nav-number">5.1.1.</span> <span class="nav-text">semget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semctl"><span class="nav-number">5.1.2.</span> <span class="nav-text">semctl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：SETALL与GETALL的简单示例"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">示例一：SETALL与GETALL的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：IPC-STAT的简单示例"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">示例二：IPC_STAT的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semop"><span class="nav-number">5.1.3.</span> <span class="nav-text">semop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：通过信号量使两个进程对同一块地址各加一千万"><span class="nav-number">5.1.4.</span> <span class="nav-text">示例一：通过信号量使两个进程对同一块地址各加一千万</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：通过信号量实现生产者消费者模型"><span class="nav-number">5.1.5.</span> <span class="nav-text">示例二：通过信号量实现生产者消费者模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">6.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建与退出"><span class="nav-number">6.2.</span> <span class="nav-text">创建与退出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建"><span class="nav-number">6.2.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#退出"><span class="nav-number">6.2.2.</span> <span class="nav-text">退出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：创建并退出线程"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">示例一：创建并退出线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待退出"><span class="nav-number">6.3.</span> <span class="nav-text">等待退出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：创建并等待退出"><span class="nav-number">6.3.1.</span> <span class="nav-text">示例一：创建并等待退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：等待退出并接收指针返回值"><span class="nav-number">6.3.2.</span> <span class="nav-text">示例二：等待退出并接收指针返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例三：等待退出并接收整型返回值"><span class="nav-number">6.3.3.</span> <span class="nav-text">示例三：等待退出并接收整型返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的取消"><span class="nav-number">6.4.</span> <span class="nav-text">线程的取消</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清理函数"><span class="nav-number">6.5.</span> <span class="nav-text">清理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：清理函数简单示例"><span class="nav-number">6.5.1.</span> <span class="nav-text">示例一：清理函数简单示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：清理函数的执行顺序"><span class="nav-number">6.5.2.</span> <span class="nav-text">示例二：清理函数的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例三：使用清理函数进行解锁"><span class="nav-number">6.5.3.</span> <span class="nav-text">示例三：使用清理函数进行解锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的互斥"><span class="nav-number">6.6.</span> <span class="nav-text">线程的互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的创建与注销"><span class="nav-number">6.6.1.</span> <span class="nav-text">锁的创建与注销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的操作"><span class="nav-number">6.6.2.</span> <span class="nav-text">锁的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：trylock的机制"><span class="nav-number">6.6.2.1.</span> <span class="nav-text">示例一：trylock的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：使用互斥锁两个线程各加2000万"><span class="nav-number">6.6.2.2.</span> <span class="nav-text">示例二：使用互斥锁两个线程各加2000万</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的属性"><span class="nav-number">6.6.3.</span> <span class="nav-text">锁的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：嵌套锁与检错锁的创建"><span class="nav-number">6.6.3.1.</span> <span class="nav-text">示例一：嵌套锁与检错锁的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：在进程使用互斥锁"><span class="nav-number">6.6.3.2.</span> <span class="nav-text">示例二：在进程使用互斥锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的同步"><span class="nav-number">6.7.</span> <span class="nav-text">线程的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建与退出-1"><span class="nav-number">6.7.1.</span> <span class="nav-text">创建与退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待和激发"><span class="nav-number">6.7.2.</span> <span class="nav-text">等待和激发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：条件变量的简单使用"><span class="nav-number">6.7.2.1.</span> <span class="nav-text">示例一：条件变量的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：多线程使用条件变量需注意死锁"><span class="nav-number">6.7.2.2.</span> <span class="nav-text">示例二：多线程使用条件变量需注意死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例三：wait包含了一次解锁与加锁"><span class="nav-number">6.7.2.3.</span> <span class="nav-text">示例三：wait包含了一次解锁与加锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例四：售票并且子线程补一次票"><span class="nav-number">6.7.2.4.</span> <span class="nav-text">示例四：售票并且子线程补一次票</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">6.8.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程属性（了解）"><span class="nav-number">6.9.</span> <span class="nav-text">线程属性（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程属性初始化"><span class="nav-number">6.9.1.</span> <span class="nav-text">线程属性初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置绑定属性"><span class="nav-number">6.9.2.</span> <span class="nav-text">设置绑定属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置分离属性"><span class="nav-number">6.9.3.</span> <span class="nav-text">设置分离属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取与设置线程优先级"><span class="nav-number">6.9.4.</span> <span class="nav-text">获取与设置线程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：通过设置属性达到线程分离"><span class="nav-number">6.9.4.1.</span> <span class="nav-text">示例一：通过设置属性达到线程分离</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">7.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础函数"><span class="nav-number">7.1.</span> <span class="nav-text">基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket信息数据结构"><span class="nav-number">7.1.1.</span> <span class="nav-text">socket信息数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据存储优先顺序的转换"><span class="nav-number">7.1.2.</span> <span class="nav-text">数据存储优先顺序的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：查看本机是大端还是小端模式"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">示例一：查看本机是大端还是小端模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址格式转化"><span class="nav-number">7.1.3.</span> <span class="nav-text">地址格式转化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：地址格式转换的简单示例"><span class="nav-number">7.1.3.1.</span> <span class="nav-text">示例一：地址格式转换的简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字地址转换"><span class="nav-number">7.1.4.</span> <span class="nav-text">名字地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：将域名转换成IP地址"><span class="nav-number">7.1.4.1.</span> <span class="nav-text">示例一：将域名转换成IP地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程"><span class="nav-number">7.2.</span> <span class="nav-text">socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">7.2.1.</span> <span class="nav-text">socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">7.2.2.</span> <span class="nav-text">bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen"><span class="nav-number">7.2.3.</span> <span class="nav-text">listen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept"><span class="nav-number">7.2.4.</span> <span class="nav-text">accept</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：accept的常用实例"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">示例一：accept的常用实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect"><span class="nav-number">7.2.5.</span> <span class="nav-text">connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recv"><span class="nav-number">7.2.6.</span> <span class="nav-text">recv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send"><span class="nav-number">7.2.7.</span> <span class="nav-text">send</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvfrom"><span class="nav-number">7.2.8.</span> <span class="nav-text">recvfrom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendto"><span class="nav-number">7.2.9.</span> <span class="nav-text">sendto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用TCP协议的流程"><span class="nav-number">7.2.10.</span> <span class="nav-text">使用TCP协议的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流程图"><span class="nav-number">7.2.10.1.</span> <span class="nav-text">流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：TCP的简单使用"><span class="nav-number">7.2.10.2.</span> <span class="nav-text">示例一：TCP的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：支持单用户断开并重连的简单聊天室"><span class="nav-number">7.2.10.3.</span> <span class="nav-text">示例二：支持单用户断开并重连的简单聊天室</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例三：多用户聊天室"><span class="nav-number">7.2.10.4.</span> <span class="nav-text">示例三：多用户聊天室</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用UDP协议的流程"><span class="nav-number">7.2.11.</span> <span class="nav-text">使用UDP协议的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流程图-1"><span class="nav-number">7.2.11.1.</span> <span class="nav-text">流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：UDP的简单使用"><span class="nav-number">7.2.11.2.</span> <span class="nav-text">示例一：UDP的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例二：UDP单用户简单聊天室"><span class="nav-number">7.2.11.3.</span> <span class="nav-text">示例二：UDP单用户简单聊天室</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置套接口选项"><span class="nav-number">7.2.12.</span> <span class="nav-text">设置套接口选项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：常用的套接口选项设置"><span class="nav-number">7.2.12.1.</span> <span class="nav-text">示例一：常用的套接口选项设置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多路复用"><span class="nav-number">8.</span> <span class="nav-text">多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#select"><span class="nav-number">8.1.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-示例1：select的实现一个两个程序交流"><span class="nav-number">8.1.1.</span> <span class="nav-text">3.1 示例1：select的实现一个两个程序交流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">8.2.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-create"><span class="nav-number">8.2.1.</span> <span class="nav-text">epoll_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">8.2.2.</span> <span class="nav-text">epoll_ctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-wait"><span class="nav-number">8.2.3.</span> <span class="nav-text">epoll_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平触发与边缘触发"><span class="nav-number">8.2.4.</span> <span class="nav-text">水平触发与边缘触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll非阻塞模型"><span class="nav-number">8.2.5.</span> <span class="nav-text">epoll非阻塞模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：epoll实现单用户聊天"><span class="nav-number">8.2.6.</span> <span class="nav-text">示例一：epoll实现单用户聊天</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例二：非阻塞边沿触发的聊天室"><span class="nav-number">8.2.7.</span> <span class="nav-text">示例二：非阻塞边沿触发的聊天室</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select和epoll的比较"><span class="nav-number">8.3.</span> <span class="nav-text">select和epoll的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select的缺陷"><span class="nav-number">8.3.1.</span> <span class="nav-text">select的缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll的改进"><span class="nav-number">8.3.2.</span> <span class="nav-text">epoll的改进</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程池"><span class="nav-number">9.</span> <span class="nav-text">进程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间传递文件描述符"><span class="nav-number">9.1.</span> <span class="nav-text">进程间传递文件描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socketpair"><span class="nav-number">9.1.1.</span> <span class="nav-text">socketpair</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendmsg"><span class="nav-number">9.1.2.</span> <span class="nav-text">sendmsg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvmsg"><span class="nav-number">9.1.3.</span> <span class="nav-text">recvmsg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：把文件描述符传递给子进程"><span class="nav-number">9.1.4.</span> <span class="nav-text">示例一：把文件描述符传递给子进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程池代码编写流程"><span class="nav-number">9.2.</span> <span class="nav-text">进程池代码编写流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例一：子进程从服务器端下载数据"><span class="nav-number">9.3.</span> <span class="nav-text">示例一：子进程从服务器端下载数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例二：使用mmap方式提高效率"><span class="nav-number">9.4.</span> <span class="nav-text">示例二：使用mmap方式提高效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例三：使用sendfile-和splice-实现零拷贝"><span class="nav-number">9.5.</span> <span class="nav-text">示例三：使用sendfile()和splice()实现零拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#杂项"><span class="nav-number">10.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#格林威治时间"><span class="nav-number">10.1.</span> <span class="nav-text">格林威治时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：gmtime的简单示例"><span class="nav-number">10.1.1.</span> <span class="nav-text">示例一：gmtime的简单示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gettimeofday"><span class="nav-number">10.2.</span> <span class="nav-text">gettimeofday</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">10.3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大页"><span class="nav-number">10.3.1.</span> <span class="nav-text">大页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存使用大页"><span class="nav-number">10.3.1.1.</span> <span class="nav-text">共享内存使用大页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap使用大页"><span class="nav-number">10.3.1.2.</span> <span class="nav-text">mmap使用大页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时钟处理"><span class="nav-number">10.4.</span> <span class="nav-text">时钟处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setitimer"><span class="nav-number">10.4.1.</span> <span class="nav-text">setitimer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例一：setitimer的简单示例"><span class="nav-number">10.4.1.1.</span> <span class="nav-text">示例一：setitimer的简单示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#描述符属性修改"><span class="nav-number">10.5.</span> <span class="nav-text">描述符属性修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例一：将标准输入设置为非阻塞"><span class="nav-number">10.5.1.</span> <span class="nav-text">示例一：将标准输入设置为非阻塞</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">0ran9e</span>

  

  
</div>











        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.2.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  



	





  





  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

</body>
</html>
